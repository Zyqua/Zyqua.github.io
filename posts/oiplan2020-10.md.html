<!DOCTYPE html>
        <html>
            <head>
                <meta charset="utf-8"/>
                <title>n-kw && n-c by others</title>
                <link rel="stylesheet" type="text/css" href="../styles.css"/>
                <link rel="stylesheet" type="text/css" href="../markdownStyles.css"/>
                <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
                <script type="text/x-mathjax-config">
                    MathJax.Hub.Config({
                        tex2jax: {inlineMath: [['$','$'], ['(',')']]}
                    });
                </script>
            </head>
            <body>
                <div class="body">
                <p class="title">striving & singing</p><h3 id="2020-08-24">2020-08-24</h3>
<p>今天上午写了总结，晚上打了队爷$\texttt{wyh}$的校内模拟赛。</p>
<h4 id="a-你为什么">A. 你为什么</h4>
<p>$\texttt{OJ}$上没有上传，所以没链接。题目大意是给出一个排列，每次询问求区间$\texttt{mex}$。</p>
<p>因为是排列所以在当前区间没有出现的数一定在当前区间的补集里出现过，所以直接维护前缀和后缀最小值，然后每次直接$O(1)$查询补集最小值即可。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int n, q, a[200100], premin[200100], sufmin[200100];

inline int min(int a, int b) { return a &lt; b ? a : b; }

int main() {
    freopen(&quot;seg.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;seg.out&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    premin[1] = a[1];
    for (int i = 2; i &lt;= n; i++) premin[i] = min(premin[i - 1], a[i]);
    sufmin[n] = a[n];
    for (int i = n - 1; i &gt;= 1; i--) sufmin[i] = min(sufmin[i + 1], a[i]);
    for (int i = 1; i &lt;= q; i++) {
        int l, r;
        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
        int ans = n;
        if (l ^ 1) ans = min(ans, premin[l - 1]);
        if (r ^ n) ans = min(ans, sufmin[r + 1]);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>
<h4 id="b-不感谢">B. 不感谢</h4>
<p><a href="https://lyoi.cc/problem/696">https://lyoi.cc/problem/696</a></p>
<p>先用最短路求出来所有点被植入病毒的最晚时间$maxdis$。一个删点的状态能推迟时间仅当对于任意一个点所有和它距离小于等于$maxdis$的特殊点都被删除。可以把删点的集合按位压缩为一个整数，如果把每个点的和它距离小于等于$maxdis$的特殊点的集合记为$b_i$，则所有包含$b_i$的状态都能够推迟时间，因此可以$k$维前缀和。</p>
<p>比赛时我对于一个删点的状态的分析不到位，还以为只要距离最长的点的所有源点都被删了时间就推迟了，但实际上不是的，最后打了个纯暴力。高维前缀和的技巧是第一次见到，看起来还是挺有用的。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

int n, m, k, sv[25], b[100100], ans;
long long dis[100100][25], maxdis;
bool vis[100100], flag[(1 &lt;&lt; 20) + 10];
struct edge { int to, next, w; };
struct graph {
    int ecnt, head[100100];
    edge edges[400100];
    inline void addedge(int u, int v, int w) {
        edges[++ecnt].to = v;
        edges[ecnt].w = w;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}g;
struct node {
    int x; long long dis;
    node(int xv = 0, long long dv = 0): x(xv), dis(dv) {}
    bool operator &lt; (const node &amp;a) const { return dis &gt; a.dis; }
};
std::priority_queue&lt;node&gt; q;

inline long long min(long long a, long long b) { return a &lt; b ? a : b; }
inline long long max(long long a, long long b) { return a &gt; b ? a : b; }
inline void dijkstra(int s) {
    memset(vis, 0, sizeof(bool) * (n + 1));
    dis[sv[s]][s] = 0;
    q.push(node(sv[s], 0));
    while (!q.empty()) {
        node f = q.top();
        q.pop();
        if (vis[f.x]) continue;
        vis[f.x] = true;
        for (int i = g.head[f.x]; i; i = g.edges[i].next) {
            int &amp;v = g.edges[i].to, w = g.edges[i].w;
            if (dis[v][s] &gt; dis[f.x][s] + w) {
                dis[v][s] = dis[f.x][s] + w;
                q.push(node(v, dis[v][s]));
            }
        }
    }
}

int main() {
    freopen(&quot;network.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;network.out&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    for (int i = 1; i &lt;= k; i++) scanf(&quot;%d&quot;, &amp;sv[i]);
    for (int i = 1; i &lt;= m; i++) {
        int u, v, w;
        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
        g.addedge(u, v, w); g.addedge(v, u, w);
    }
    memset(dis, 0x3f, sizeof dis);
    for (int i = 1; i &lt;= k; i++) dijkstra(i);
    for (int x = 1; x &lt;= n; x++) {
        long long d = 0x3fffffffffffffff;
        for (int i = 1; i &lt;= k; i++) d = min(d, dis[x][i]);
        maxdis = max(maxdis, d);
    }
    for (int x = 1; x &lt;= n; x++) {
        for (int i = 1; i &lt;= k; i++)
            if (dis[x][i] &lt;= maxdis) b[x] |= (1 &lt;&lt; (i - 1));
        flag[b[x]] = true;
    }
    for (int stt = 0; stt &lt;= (1 &lt;&lt; k) - 1; stt++) {
        for (int i = 1; i &lt;= k; i++)
            if (stt &amp; (1 &lt;&lt; (i - 1))) flag[stt] = flag[stt] || flag[stt ^ (1 &lt;&lt; (i - 1))];
        if (!flag[stt]) ans++;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="c-ccf">C. CCF</h4>
<p><a href="https://lyoi.cc/problem/698">https://lyoi.cc/problem/698</a></p>
<p>显然这是个区间$\texttt{DP}$。那么设$dp[i][j][k]$表示区间$[i,j]$最后$k$保留的概率，则有</p>
<p>$$dp[i][j][k]=\dfrac{1}{j-i}\sum_w\dfrac{a_k}{a_k+a_w}\sum_pdp[i][p][k]dp[p+1][j][w]$$</p>
<p>可以理解为枚举最后一次和$k$打的位置$w$，$k$和$w$在此之前合并的区间分别是区间前后缀，那么再枚举分割点，$O(n^5)$$\texttt{DP}$。$\dfrac{1}{j-i}$表示$k$和$w$最后一次打的概率。</p>
<p>实际上最后一维没用，可以设$f[i][j]$表示区间$[i,j]$最后$i$保留，$g[i][j]$表示区间$[i,j]$最后$j$保留。那么有：</p>
<p>$$f[i][j]=\dfrac{1}{j-i}\sum_{w=i+1}^jf[w][j]\dfrac{a_i}{a_i+a_w}\sum_{k=i}^{w-1}f[i][k]g[k+1][w]$$</p>
<p>$$g[i][j]=\dfrac{1}{j-i}\sum_{w=i}^{j-1}g[i][w]\dfrac{a_j}{a_j+a_w}\sum_{k=w}^{j-1}f[w][k]g[k+1][j]$$</p>
<p>最后答案就是$f[1][k]g[k][n]$。这样就可以$O(n^4)$$\texttt{DP}$了。</p>
<p>最后那个枚举分割点$k$的式子形式非常类似，那么可以发扬预处理精神，预处理$h[i][j]$：</p>
<p>$$h[i][j]=\sum_{k=i}^{j-1}f[i][k][k+1][j]$$</p>
<p>在枚举区间长度时，让$h$在$f$和$g$之前先更新即可。</p>
<p>因为是模意义下的概率所以需要求逆元，但如果边$\texttt{DP}$边算逆元会使复杂度再乘上一个$\log$，然后超时。继续发扬预处理精神，预处理逆元即可。总复杂度$O(n^3)$。</p>
<p>比赛时我一眼看出这是道区间$\texttt{DP}$，状态也设计出来了(虽然想出来的是$O(n^5)$做法的状态但毕竟还是能拿到分的)，但方程推得不对，样例都过不去，于是去写$\texttt{B}$题了。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

const int MOD = 998244353;
int n, k, a[510], f[510][510], g[510][510], h[510][510], suminv[510][510];

void exgcd(int a, int b, int &amp;x, int &amp;y) {
    if (!b) { x = 1; y = 0; return; }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
}
inline int inv(int a) { int x, y; exgcd(a, MOD, x, y); return (x % MOD + MOD) % MOD; }

int main() {
    freopen(&quot;game.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;game.out&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    for (int i = 1; i &lt;= n; i++)
        for (int j = i + 1; j &lt;= n; j++) suminv[i][j] = suminv[j][i] = inv(a[i] + a[j]);
    for (int i = 1; i &lt;= n; i++) f[i][i] = g[i][i] = 1;
    for (int l = 2; l &lt;= n; l++) {
        for (int i = 1; i + l - 1 &lt;= n; i++) {
            int j = i + l - 1;
            for (int k = i; k &lt;= j - 1; k++) h[i][j] = (h[i][j] + (long long)f[i][k] * g[k + 1][j] % MOD) % MOD;
        }
        int invl = inv(l - 1);
        for (int i = 1; i + l - 1 &lt;= n; i++) {
            int j = i + l - 1;
            for (int w = i + 1; w &lt;= j; w++)
                f[i][j] = (f[i][j] + (long long)f[w][j] * a[i] % MOD * suminv[i][w] % MOD * h[i][w] % MOD) % MOD;
            f[i][j] = (long long)f[i][j] * invl % MOD;
            for (int w = i; w &lt;= j - 1; w++)
                g[i][j] = (g[i][j] + (long long)g[i][w] * a[j] % MOD * suminv[j][w] % MOD * h[w][j] % MOD) % MOD;
            g[i][j] = (long long)g[i][j] * invl % MOD;
        }
    }
    printf(&quot;%d\n&quot;, (int)((long long)g[1][k] * f[k][n] % MOD));
    return 0;
}</code></pre>
<p>这场比赛我的分数是$100+24+0=124$，总排名第一，毕竟拿不到第一的话我就可以直接退役了。而且题目难度其实对我来说不算太难，但让我自己写又不容易写出来。</p>
<h3 id="2020-08-25">2020-08-25</h3>
<h4 id="poi2002haoi2007反素数">[POI2002][HAOI2007]反素数</h4>
<p><a href="https://www.luogu.com.cn/problem/P1463">https://www.luogu.com.cn/problem/P1463</a></p>
<p>范围内的反素数实际上是约数个数最多的最小数。$\texttt{int}$范围内的数字最多只能有$10$个不同的质因子，质因子的指数最大是$30$。一个反质数的质因数指数一定单调不递增，否则可以交换两个逆序质因数，这样约数个数不变，且数字变小。根据这几条性质直接搜索即可。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

const int prime[11] = { 0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
int n, ans, anscnt;

inline int min(int a, int b) { return a &lt; b ? a : b; }
void dfs(int x, int lst, int mul, int cnt) {
    if (anscnt &lt; cnt) anscnt = cnt, ans = mul;
    else if (anscnt == cnt) ans = min(ans, mul);
    if (x == 11) return;
    int p = 1;
    for (int i = 0; i &lt;= lst; i++) {
        if ((long long)mul * p &gt; n) continue;
        dfs(x + 1, i, mul * p, cnt * (i + 1));
        p *= prime[x];
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    dfs(1, 30, 1, 1);
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="因子和">因子和</h4>
<p><a href="https://www.luogu.com.cn/problem/P1593">https://www.luogu.com.cn/problem/P1593</a></p>
<p>把一个数质因数分解为$\prod_{i=1}^kp_i^{c_i}$，则这个数的所有因子的和为$\prod_{i=1}^k\sum_{j=0}^{c_i}p_i^j$。后面的和式实际上就是等比数列求和，即$\dfrac{p^{c_i+1}-1}{p_i-1}$。当$p_i\equiv 1\pmod {9901}$时$p_i-1$不存在逆元，但显然这个等比数列的值为$c_i+1$，这样就不需要计算逆元了。还有当$p_i\equiv 0\pmod{9901}$时$p_i-1$如果直接算就成了负数，需要加$9901$再模。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

const int MOD = 9901;
int a, b, d[15], c[15], pcnt, ans = 1;

inline void factorize(int x) {
    for (int i = 2; i * i &lt;= x; i++) {
        if (x % i) continue;
        d[++pcnt] = i;
        while (!(x % i)) x /= i, c[pcnt]++;
    }
    if (x &gt; 1) d[++pcnt] = x, c[pcnt]++;
}
inline int pwr(int x, int k) {
    int ans = 1;
    while (k) {
        if (k &amp; 1) ans = (long long)ans * x % MOD;
        x = (long long)x * x % MOD;
        k &gt;&gt;= 1;
    }
    return ans;
}
inline int inv(int x) { return pwr(x, MOD - 2); }

int main() {
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    factorize(a);
    for (int i = 1; i &lt;= pcnt; i++) c[i] *= b;
    for (int i = 1; i &lt;= pcnt; i++) {
        if ((d[i] - 1) % MOD) ans = (long long)ans * (pwr(d[i], c[i] + 1) - 1 + MOD) % MOD * inv(d[i] - 1) % MOD;
        else ans = (long long)ans * (c[i] + 1) % MOD;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="签到题">签到题</h4>
<p><a href="https://www.luogu.com.cn/problem/P3601">https://www.luogu.com.cn/problem/P3601</a></p>
<p>$qiandao(x)=x-\varphi(x)$。因此计算$\varphi$即可。$l,r$的范围较大，不能直接筛，但$r-l$比较小，可以枚举区间内的每个数。考虑欧拉函数的计算过程$\varphi(x)=x\prod_{i=1}^k(1-\dfrac{1}{p_i})$，如果直接对于每个数$O(\sqrt n)$暴力计算显然不行，但可以枚举质因子，对于每个质数计算它在$[l,r]$中对所有它的倍数的贡献。因为任意一个正整数数$x$最多只包含一个大于$\sqrt x$的质因子，所以可以预处理出来小于等于$\sqrt r$的所有质数，然后剩下一个质因子直接计算即可。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

const int MOD = 666623333;
int prime[100100], pcnt, ans;
long long l, r, phi[1000100], num[1000100];
bool isprime[1000100];

int main() {
    scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r);
    for (int i = 0; i &lt;= r - l; i++) num[i] = phi[i] = l + i;
    for (int i = 2; (long long)i * i &lt;= r; i++) isprime[i] = true;
    for (int i = 2; (long long)i * i &lt;= r; i++) {
        if (isprime[i]) prime[++pcnt] = i;
        for (int j = 1; j &lt;= pcnt &amp;&amp; (long long)i * prime[j] * i * prime[j] &lt;= r; j++) {
            isprime[i * prime[j]] = false;
            if (!(i % prime[j])) break;
        }
    }
    for (int i = 1; i &lt;= pcnt; i++) {
        int p = prime[i];
        for (long long x = (l / p + (l % p ? 1 : 0)) * p; x &lt;= r; x += p) {
            phi[x - l] = phi[x - l] / p * (p - 1);
            while (!(num[x - l] % p)) num[x - l] /= p;
        }
    }
    for (int i = 0; i &lt;= r - l; i++)
        if (num[i] &gt; 1) phi[i] = phi[i] / num[i] * (num[i] - 1), num[i] = 1;
    for (int i = 0; i &lt;= r - l; i++) ans = ((long long)ans + l + i - phi[i]) % MOD;
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="素数密度">素数密度</h4>
<p><a href="https://www.luogu.com.cn/problem/P1835">https://www.luogu.com.cn/problem/P1835</a></p>
<p>和上题一样的方法，但是注意不要爆$\texttt{int}$。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int l, r, prime[100100], pcnt, ans;
bool isprime[1000100];

int main() {
    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
    for (int i = 2; (long long)i * i &lt;= r; i++) isprime[i] = true;
    for (int i = 2; (long long)i * i &lt;= r; i++) {
        if (isprime[i]) prime[++pcnt] = i;
        for (int j = 1; j &lt;= pcnt &amp;&amp; (long long)i * prime[j] * i * prime[j] &lt;= r; j++) {
            isprime[i * prime[j]] = false;
            if (!(i % prime[j])) break;
        }
    }
    memset(isprime, 1, sizeof isprime);
    for (int i = 1; i &lt;= pcnt; i++) {
        int p = prime[i];
        for (long long x = ((long long)l / p + (l % p ? 1 : 0)) * p; x &lt;= r; x += p)
            if (x ^ p) isprime[x - l] = false;
    }
    for (int i = 0; i &lt;= r - l; i++)
        if (isprime[i]) ans++;
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="tjoi2007路标设置">[TJOI2007]路标设置</h4>
<p><a href="https://www.luogu.com.cn/problem/P3853">https://www.luogu.com.cn/problem/P3853</a></p>
<p>显然直接二分即可。注意特判相邻距离等于二分值的倍数的情况。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int l, n, k, pos[100100];

bool check(int mid) {
    int cnt = 0;
    for (int i = 2; i &lt;= n; i++)
        cnt += (pos[i] - pos[i - 1]) / mid + ((pos[i] - pos[i - 1]) % mid ? 0 : -1);
    return cnt &lt;= k;
}

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;l, &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;pos[i]);
    int lx = 1, rx = l + 1;
    while (lx &lt; rx) {
        int mid = lx + (rx - lx &gt;&gt; 1);
        if (check(mid)) rx = mid;
        else lx = mid + 1;
    }
    printf(&quot;%d\n&quot;, lx);
    return 0;
}</code></pre>
<a href="../posts.html" class="link" style="display:block; text-align:center;">return</a>
</div>
</body>
</html>