<!DOCTYPE html>
        <html>
            <head>
                <meta charset="utf-8"/>
                <title>n-kw && n-c by others</title>
                <link rel="stylesheet" type="text/css" href="../styles.css"/>
                <link rel="stylesheet" type="text/css" href="../markdownStyles.css"/>
                <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css">
                <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>
                <script>
                var katex_config = {
                    delimiters: 
                    [
                        {left: "$$", right: "$$", display: true},
                        {left: "$", right: "$", display: false}
                    ]
                };
                </script>
                <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/contrib/auto-render.min.js" onload="renderMathInElement(document.body,katex_config)"></script>
            </head>
            <body>
                <div class="body">
                <p class="title">striving & singing</p><h3 id="2020-10-19">2020-10-19</h3>
<h4 id="scoi2009生日礼物">[SCOI2009]生日礼物</h4>
<p><a href="https://www.luogu.com.cn/problem/P2564">https://www.luogu.com.cn/problem/P2564</a></p>
<p>一看题目显然可以双指针，那么先把坐标离散化，再记录每个坐标上的颜色，这样时间复杂度是$O(n\log n)$的，看起来可以，但是空间复杂度是$O(nk)$的，交上去直接 MLE 了。另一种更简单的方法是把珠子按照坐标排序，然后直接双指针即可，时间复杂度也是$O(n\log n)$，空间复杂度$O(n)$。</p>
<p>还有一种方法是先把所有颜色中坐标最小的加入堆中，然后每次取出堆中坐标最小的，把它的颜色对应的没有加入过堆的坐标最小的柱子加进去，这样复杂度是$O(n\log k)$的，更优。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;algorithm&gt;

int n, k, cnt[61], ccnt, icnt, ans = 0x7fffffff;
std::pair&lt;int, int&gt; itm[1000100];

inline int min(int a, int b) { return a &lt; b ? a : b; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt;= k; i++) {
        int t; scanf(&quot;%d&quot;, &amp;t);
        for (int j = 1; j &lt;= t; j++) {
            int x; scanf(&quot;%d&quot;, &amp;x);
            itm[++icnt] = std::make_pair(x, i);
        }
    }
    std::sort(itm + 1, itm + icnt + 1);
    int cur = 1;
    for (int i = 1; i &lt;= n; i++) {
        while (cur &lt;= n &amp;&amp; ccnt &lt; k) {
            if (!cnt[itm[cur].second]) ccnt++;
            cnt[itm[cur].second]++;
            cur++;
        }
        if (ccnt == k) ans = min(ans, itm[cur - 1].first - itm[i].first);
        cnt[itm[i].second]--;
        if (!cnt[itm[i].second]) ccnt--;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="scoi2005最大子矩阵">[SCOI2005]最大子矩阵</h4>
<p><a href="https://www.luogu.com.cn/problem/P2331">https://www.luogu.com.cn/problem/P2331</a></p>
<p>一看$m\le 2$，可以直接想出一个状压 DP，设$dp[i][j][s]$表示前 i 行选了 j 个子矩阵，最后一行选的状态是 s 时的最大权值，其中状态 s 的第 k 位表示第 i 行的对应位置选没选。然后每个状态的决策有和前面的矩阵合并，和自己单独成为一个矩阵两种，分情况讨论即可。</p>
<p>但这样没法处理某一行中的两列属于不同的两个矩阵的情况(样例就是一个例子)，解决方法是再加一种状态，当 s = 4 时表示两个位置都选了，但属于不同的两个矩阵，然后继续分情况讨论即可。</p>
<p>注意分类讨论的状态转移细节，把一个 3 写成了 2 调了一个小时。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, m, k, a[110][3], dp[110][11][5], ans;

inline int max(int a, int b) { return a &gt; b ? a : b; }

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;a[i][j]);
    memset(dp, -0x3f, sizeof dp);
    dp[0][0][0] = 0;
    if (m == 1) {
        for (int i = 1; i &lt;= n; i++)
            for (int j = 0; j &lt;= k; j++) {
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1]);
                dp[i][j][1] = dp[i - 1][j][1] + a[i][1];
                if (j) dp[i][j][1] = max(dp[i][j][1], max(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1]) + a[i][1]);
            }
        ans = max(dp[n][k][0], dp[n][k][1]);
    }
    else if (m == 2) {
        for (int i = 1; i &lt;= n; i++)
            for (int j = 0; j &lt;= k; j++) {
                for (int lst = 0; lst &lt;= 4; lst++) {
                    dp[i][j][0] = max(dp[i][j][0], dp[i - 1][j][lst]);
                    if (j) dp[i][j][1] = max(dp[i][j][1], dp[i - 1][j - 1][lst] + a[i][2]);
                    if (j) dp[i][j][2] = max(dp[i][j][2], dp[i - 1][j - 1][lst] + a[i][1]);
                    if (j) dp[i][j][3] = max(dp[i][j][3], dp[i - 1][j - 1][lst] + a[i][1] + a[i][2]);
                    if (j &gt;= 2) dp[i][j][4] = max(dp[i][j][4], dp[i - 1][j - 2][lst] + a[i][1] + a[i][2]);
                }
                dp[i][j][1] = max(dp[i][j][1], max(dp[i - 1][j][1], dp[i - 1][j][4]) + a[i][2]);
                dp[i][j][2] = max(dp[i][j][2], max(dp[i - 1][j][2], dp[i - 1][j][4]) + a[i][1]);
                dp[i][j][3] = max(dp[i][j][3], dp[i - 1][j][3] + a[i][1] + a[i][2]);
                dp[i][j][4] = max(dp[i][j][4], dp[i - 1][j][4] + a[i][1] + a[i][2]);
                if (j) dp[i][j][4] = max(dp[i][j][4], max(dp[i - 1][j - 1][1], dp[i - 1][j - 1][2]) + a[i][1] + a[i][2]);
            }
        for (int s = 0; s &lt;= 4; s++) ans = max(ans, dp[n][k][s]);
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="hnoi2010合唱队">[HNOI2010]合唱队</h4>
<p><a href="https://www.luogu.com.cn/problem/P3205">https://www.luogu.com.cn/problem/P3205</a></p>
<p>因为每次都是在序列的开头或结尾加数字，所以不难想到以区间作为阶段来 DP。设$dp[i][j][0/1]$表示区间$[i,j]$最后一次加入在了队头 / 队尾的方案数，初始化$dp[i][i][0]=dp[i][i][1]=1$，然后直接分类讨论即可。</p>
<p>一测样例发现输出的方案数是样例的两倍，其实是因为$dp[i][i][0]=dp[i][i][1]=1$导致只有一个人的序列方案数是 2，那么可以直接钦定一个人的序列只能从队头插入，即$dp[i][i][0]=1,dp[i][i][1]=0$。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

const int MOD = 19650827;
int n, h[1010], dp[1010][1010][2];

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;h[i]), dp[i][i][0] = 1;
    for (int l = 2; l &lt;= n; l++)
        for (int i = 1; i + l - 1 &lt;= n; i++) {
            int j = i + l - 1;
            if (h[i] &lt; h[i + 1]) dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][0]) % MOD;
            if (h[i] &lt; h[j]) dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][1]) % MOD;
            if (h[j] &gt; h[i]) dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][0]) % MOD;
            if (h[j] &gt; h[j - 1]) dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][1]) % MOD;
        }
    printf(&quot;%d\n&quot;, (dp[1][n][0] + dp[1][n][1]) % MOD);
    return 0;
}</code></pre>
<h4 id="重建道路">重建道路</h4>
<p><a href="https://www.luogu.com.cn/problem/P1272">https://www.luogu.com.cn/problem/P1272</a></p>
<p>设$dp[x][i]$表示节点 x 保留了 i 个节点，且保留了根节点时最少需要去掉的边数，那么有：</p>
<p>$$dp[x][i]=\begin{cases}deg[x]-[x\not =1]&amp;i=1\\min_{j=0}^i{dp[x][i-j]+dp[v][j]-1}\end{cases}$$</p>
<p>其中$deg[x]$是 x 的度数，v 是节点 x 的子节点。-1 是因为在$dp[x][i-j]$中把$(x,v)$这条边删掉了，而要保留子节点就不能删这条边，所以删的边数 -1。</p>
<p>答案是$\min_{x=1}^n{dp[x][s]+[x\not=1]}$。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, s, dp[155][155], ans = 0x3fffffff, deg[155];
struct edge { int to, next; };
struct graph {
    int ecnt = 1, head[155];
    edge edges[310];
    inline void addedge(int u, int v) {
        edges[++ecnt].to = v;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}g;

inline int min(int a, int b) { return a &lt; b ? a : b; }

void dfs(int x, int lst) {
    dp[x][1] = deg[x] - (x == 1 ? 0 : 1);
    for (int i = g.head[x]; i; i = g.edges[i].next) {
        if ((i ^ lst) == 1) continue;
        int &amp;v = g.edges[i].to;
        dfs(v, i);
        for (int j = s; j &gt;= 2; j--)
            for (int k = 0; k &lt;= j; k++) dp[x][j] = min(dp[x][j], dp[x][j - k] + dp[v][k] - 1);
    }
    ans = min(ans, dp[x][s] + (x == 1 ? 0 : 1));
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;s);
    for (int i = 1; i &lt; n; i++) {
        int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        g.addedge(u, v); g.addedge(v, u);
        deg[u]++; deg[v]++;
    }
    memset(dp, 0x3f, sizeof dp);
    dfs(1, 0);
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="面基">面基</h4>
<p><a href="https://www.luogu.com.cn/problem/P5628">https://www.luogu.com.cn/problem/P5628</a></p>
<p>这个是 USACO 的原题(luogu P3047)，以前做过那个原题但是现在又不太会了，所以再做一遍。为方便，下面讲的是原题的思路，本题在原题基础上稍加转化即可。</p>
<p>设$dp[x][i]$表示距离节点 x 距离不超过 i 的节点的权值和，那么可以先 dfs 一遍，求出距离节点 x 距离不超过 i 的 x 的子树内的节点的权值和，做法很显然，就不写了。然后可以换根+容斥，在第一遍 dfs 后，因为节点 1 是根节点所以节点 1 的 dp 值就是实际值，于是第二遍 dfs 时可以让$dp[v][i]$加上父节点的$dp[x][i-1]$，合并得到不是子树内的节点的权值和，而$dp[v][i-2]$多算了一遍所以还要减去。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int n, k, size[30100];
long long dp[30100][210], ans;
struct edge { int to, next, w; };
struct graph {
    int ecnt = 1, head[30100];
    edge edges[60100];
    inline void addedge(int u, int v) {
        edges[++ecnt].to = v;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}g;

void dfs1(int x, int lst) {
    size[x] = 1;
    for (int i = g.head[x]; i; i = g.edges[i].next) {
        if ((i ^ lst) == 1) continue;
        int &amp;v = g.edges[i].to;
        dfs1(v, i);
        size[x] += size[v];
        dp[x][0] += (long long)(n - size[v]) * size[v];
        for (int j = 1; j &lt;= k; j++) dp[x][j] += dp[v][j - 1];
    }
    for (int j = 1; j &lt;= k; j++) dp[x][j] += dp[x][0];
}
void dfs2(int x, int lst) {
    for (int i = g.head[x]; i; i = g.edges[i].next) {
        if ((i ^ lst) == 1) continue;
        int &amp;v = g.edges[i].to;
        for (int j = k; j &gt;= 1; j--) dp[v][j] += dp[x][j - 1] - (j &gt;= 2 ? dp[v][j - 2] : 0);
        dp[v][0] += (long long)(n - size[v]) * size[v];
        dfs2(v, i);
    }
}
inline long long max(long long a, long long b) { return a &gt; b ? a : b; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt; n; i++) {
        int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        g.addedge(u, v); g.addedge(v, u);
    }
    dfs1(1, 0);
    dfs2(1, 0);
    for (int i = 1; i &lt;= n; i++) ans = max(ans, dp[i][k]);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}</code></pre>
<h3 id="2020-10-20">2020-10-20</h3>
<h4 id="括号树">括号树</h4>
<p><a href="https://www.luogu.com.cn/problem/P5658">https://www.luogu.com.cn/problem/P5658</a></p>
<p>当时考场上想出了$O(n^2)$的暴力做法，但是树上的情况写挂了调不出来，于是只好写了个链的情况，拿了 35 分。要是树上的情况没写挂，拿到 50 分，那就可以省一了。</p>
<p>其实是一个线性 DP 强行搬到了树上。考虑链上的情况，设$dp[i]$表示以第 i 个位置结尾的合法括号序列个数，显然若$s[i]=&#39;(&#39;$或者$s[i]=&#39;)&#39;$但没有匹配的左括号那么$dp[i]=0$，否则设匹配的左括号的位置为 lst，那么有$dp[i]=dp[lst-1]+1$。感觉挺对的，不过考场上没想出来，毕竟太菜了。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;stack&gt;

int n, f[500100];
long long dp[500100], ans;
char s[500100];
struct edge { int to, next; };
struct graph {
    int ecnt, head[500100];
    edge edges[500100];
    inline void addedge(int u, int v) {
        edges[++ecnt].to = v;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}g;
std::stack&lt;int&gt; stk;

void dfs1(int x) {
    int t = 0;
    if (s[x] == &#39;(&#39;) stk.push(x);
    else if (s[x] == &#39;)&#39; &amp;&amp; !stk.empty()) {
        dp[x] = dp[f[stk.top()]] + 1;
        t = stk.top(); stk.pop();
    }
    for (int i = g.head[x]; i; i = g.edges[i].next) {
        int &amp;v = g.edges[i].to;
        dfs1(v);
    }
    if (s[x] == &#39;(&#39;) stk.pop();
    else if (t) stk.push(t);
}
void dfs2(int x) {
    for (int i = g.head[x]; i; i = g.edges[i].next) {
        int &amp;v = g.edges[i].to;
        dp[v] += dp[x];
        dfs2(v);
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    scanf(&quot;%s&quot;, s + 1);
    for (int i = 2; i &lt;= n; i++) {
        scanf(&quot;%d&quot;, &amp;f[i]);
        g.addedge(f[i], i);
    }
    dfs1(1);
    dfs2(1);
    for (int i = 1; i &lt;= n; i++) ans ^= i * dp[i];
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="cqoi2007涂色">[CQOI2007]涂色</h4>
<p><a href="https://www.luogu.com.cn/problem/P4170">https://www.luogu.com.cn/problem/P4170</a></p>
<p>因为涂的是一个区间所以想到区间 DP，设$dp[i][j]$表示$[i,j]$涂成目标状态需要的最少次数，那么有两种决策，一种是若$s[i]=s[j]$，那么可以由$dp[i+1][j-1]$转移来，另一种是通用的，直接枚举中间点，合并两个子区间。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, dp[55][55];
char s[55];

inline int min(int a, int b) { return a &lt; b ? a : b; }

int main() {
    scanf(&quot;%s&quot;, s + 1);
    n = strlen(s + 1);
    memset(dp, 0x3f, sizeof dp);
    for (int i = 1; i &lt;= n; i++) dp[i][i] = dp[i][i - 1] = 1;
    for (int l = 2; l &lt;= n; l++)
        for (int i = 1; i + l - 1 &lt;= n; i++) {
            int j = i + l - 1;
            if (s[i] == s[j]) dp[i][j] = min(dp[i][j], min(dp[i + 1][j], dp[i][j - 1]));
            for (int k = i; k &lt; j; k++) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
        }
    printf(&quot;%d\n&quot;, dp[1][n]);
    return 0;
}</code></pre>
<h4 id="tjoi2007调整队形">[TJOI2007]调整队形</h4>
<p><a href="https://www.luogu.com.cn/problem/P3847">https://www.luogu.com.cn/problem/P3847</a></p>
<p>看完题面可以发现是一个区间 DP，但是转移感觉不太明白，但我决定先写一个试试，尽量不依靠题解。然后瞎编了两种转移方式，没想到交上去直接过了，挺好的。</p>
<p>代码中第一种转移对应加入/删除一个人，第二种转移对应改变一个人的颜色。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, w[3010], dp[3010][3010];

inline int min(int a, int b) { return a &lt; b ? a : b; }

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;w[i]);
    memset(dp, 0x3f, sizeof dp);
    for (int i = 1; i &lt;= n; i++) dp[i][i] = dp[i][i - 1] = 0;
    for (int l = 2; l &lt;= n; l++)
        for (int i = 1; i + l - 1 &lt;= n; i++) {
            int j = i + l - 1;
            dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
            if (w[i] == w[j]) dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);
            else dp[i][j] = min(dp[i][j], dp[i + 1][j - 1] + 1);
        }
    printf(&quot;%d\n&quot;, dp[1][n]);
    return 0;
}</code></pre>
<h4 id="boi2003gem-气垫车">[BOI2003]Gem 气垫车</h4>
<p><a href="https://www.luogu.com.cn/problem/P4395">https://www.luogu.com.cn/problem/P4395</a></p>
<p>设$dp[x][i]$表示节点 x 选了权值 i 时子树的最小权值和，那么有</p>
<p>$$dp[x][i]=i+\sum_v\min_{i\not =j}{dp[v][j]}$$</p>
<p>因为只有$i\not=j$这一个限制，所以集合${dp[v][j]}$中要么取最小值，要么取次小值，那么就可以只存最小值，次小值和取最小值时 j 的值。DP 时若子节点取最小值时的 j 和当前枚举到的权值相同，则需要取次小值。然后就把这个$O(n^2)$做法优化到了$O(n)$。</p>
<p>代码实现中，$sum[j]$存的是当前节点的权值取$j$时实际 DP 值(有些子节点取了次小值)和全部子节点取最小值时的差。之所以不直接存实际 DP 值，是因为这样做其他取最小值的点就不太好算了。总之代码实现也是挺有技巧的。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, f[10100], g[10100], df[10100], sum[10100];
bool vis[10100];
struct edge { int to, next; };
struct graph {
    int ecnt = 1, head[10100];
    edge edges[20100];
    inline void addedge(int u, int v) {
        edges[++ecnt].to = v;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}gr;

inline void upd(int x, int v, int dv) {
    if (v &lt; f[x]) { g[x] = f[x]; f[x] = v; df[x] = dv; }
    else if (v &lt; g[x]) g[x] = v;
}
void dfs(int x, int lst) {
    int s = 0, cur = 1;
    for (int i = gr.head[x]; i; i = gr.edges[i].next) {
        if ((i ^ lst) == 1) continue;
        dfs(gr.edges[i].to, i);
    }
    for (int i = gr.head[x]; i; i = gr.edges[i].next) {
        if ((i ^ lst) == 1) continue;
        int &amp;v = gr.edges[i].to;
        s += f[v];
        sum[df[v]] += g[v] - f[v]; vis[df[v]] = true;
    }
    while (vis[cur]) cur++; upd(x, s + cur, cur);
    cur++; while (vis[cur]) cur++; upd(x, s + cur, cur);
    for (int i = gr.head[x]; i; i = gr.edges[i].next) {
        if ((i ^ lst) == 1) continue;
        int &amp;v = gr.edges[i].to;
        if (!vis[df[v]]) continue;
        upd(x, s + sum[df[v]] + df[v], df[v]);
        sum[df[v]] = 0; vis[df[v]] = false;
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt; n; i++) {
        int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        gr.addedge(u, v); gr.addedge(v, u);
    }
    memset(f, 0x3f, sizeof f);
    memset(g, 0x3f, sizeof g);
    dfs(1, 0);
    printf(&quot;%d\n&quot;, f[1]);
    return 0;
}</code></pre>
<h4 id="ceoi2010-day2-pin">[CEOI2010 day2] pin</h4>
<p><a href="https://www.luogu.com.cn/problem/P6521">https://www.luogu.com.cn/problem/P6521</a></p>
<p>恰好 d 个位置不同，相当于恰好 4 - d 个位置相同。可以容斥一下，设$f[i]$表示恰好 i 个位置相同的个数，$g[i]$表示枚举哪 i 个位置相同，然后计算得出的个数(也被称为钦定 i 个位置相同的个数)，那么有：</p>
<p>$$f[i]=g[i]-\sum_{j=i+1}^4\binom{j}{i}f[j]$$</p>
<p>实际上就是枚举有多少个满足大于 i 个位置相同，设为 j ，然后每个对在$g[i]$中被计算了$\binom{j}{i}$次，直接减去即可。</p>
<p>另一种做法是二项式反演。同样设$f[i]$表示恰好，$g[i]$表示钦定，那么有：</p>
<p>$$g[i]=\sum_{j=i}^4\binom{j}{i}f[j]$$</p>
<p>直接套反演公式，得</p>
<p>$$f[i]=\sum_{j=i}^4(-1)^{j-i}\binom{j}{i}g[j]$$</p>
<p>同样可以得出正确答案。</p>
<p>二项式反演也叫广义容斥，至于为什么叫广义容斥我也不懂，感觉它只是用了一下容斥原理。有三种形式：</p>
<p>$$f(i)=\sum_{j=0}^i(-1)^j\binom{i}{j}g(j)\Leftrightarrow g(i)=\sum_{j=0}^i(-1)^j\binom{i}{j}f(j)$$</p>
<p>这个好像没啥用。</p>
<p>$$g(i)=\sum_{j=a}^i\binom{i}{j}f(j)\Leftrightarrow f(i)=\sum_{j=a}^i(-1)^{i-j}\binom{i}{j}g(j)$$</p>
<p>令$g(i)$表示钦定选最多 i 个的方案数，$f(i)$表示选恰好 i 个的方案数，那么就可以利用它实现两者之间的转化。</p>
<p>$$g(i)=\sum_{j=i}^n\binom{j}{i}f(j)\Leftrightarrow f(i)=\sum_{j=i}^n(-1)^{j-i}\binom{j}{i}g(j)$$</p>
<p>令$g(i)$表示钦定选最少 i 个的方案数，$f(i)$表示选恰好 i 个的方案数，那么也可以利用它实现两者之间的转化。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;

int n, d, binom[5][5], ans, f[5], g[5];
std::map&lt;std::string, int&gt; cnt;

inline int bit(int x) {
    int ans = 0;
    for (; x; x = (x - 1) &amp; x) ans++;
    return ans;
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;d);
    d = 4 - d;
    binom[0][0] = 1;
    for (int i = 1; i &lt;= 4; i++)
        for (int j = 0; j &lt;= 4; j++) binom[i][j] = binom[i - 1][j] + binom[i - 1][j - 1];
    for (int i = 1; i &lt;= n; i++) {
        memset(f, 0, sizeof f); memset(g, 0, sizeof g);
        std::string str;
        std::cin &gt;&gt; str;
        for (int s = 0; s &lt;= 15; s++) {
            std::string str1; str1.resize(4);
            for (int j = 0; j &lt; 4; j++) {
                if (s &amp; (1 &lt;&lt; j)) str1[j] = str[j];
                else str1[j] = &#39;$&#39;;
            }
            if (cnt.count(str1)) g[bit(s)] += cnt[str1];
            cnt[str1]++;
        }
        for (int i = 4; i &gt;= d; i--) {
            f[i] = g[i];
            for (int j = i + 1; j &lt;= 4; j++) f[i] -= binom[j][i] * f[j];
        }
        ans += f[d];
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<a href="../posts.html" class="link" style="display:block; text-align:center;">return</a>
</div>
</body>
</html>