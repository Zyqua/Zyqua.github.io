<!DOCTYPE html>
        <html>
            <head>
                <meta charset="utf-8"/>
                <title>n-kw && n-c by others</title>
                <link rel="stylesheet" type="text/css" href="../styles.css"/>
                <link rel="stylesheet" type="text/css" href="../markdownStyles.css"/>
                <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css">
                <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>
                <script>
                var katex_config = {
                    delimiters: 
                    [
                        {left: "$$", right: "$$", display: true},
                        {left: "$", right: "$", display: false}
                    ]
                };
                </script>
                <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/contrib/auto-render.min.js" onload="renderMathInElement(document.body,katex_config)"></script>
            </head>
            <body>
                <div class="body">
                <p class="title">striving & singing</p><h3 id="2020-10-12">2020-10-12</h3>
<p>从今天起开始停课，每天 7 个小时用来睡觉，1 个小时用来吃饭、活动和其他零碎事情，剩下 16 个小时全部用来卷。</p>
<h4 id="矩阵取数游戏">矩阵取数游戏</h4>
<p><a href="https://www.luogu.com.cn/problem/P1005">https://www.luogu.com.cn/problem/P1005</a></p>
<p>不同行之间互不影响，那么可以设$dp[x][i][j]$表示第 x 行取了前 i 个数和后 j 个数时这一行的最大分数，那么有：</p>
<p>$$dp[x][i][j]=\max(dp[x][i-1][j]+2^{m-(j-i+1)}a[x][i-1],dp[x][i][j+1]+2^{m-(j-i+1)}a[x][j+1])$$</p>
<p>然后还得写高精。注意高精的写法，在比较大小时比较两数的位数，因为压了位所以不能直接比较数组的长度，需要长度 -1 乘 8 再加上末位的位数。另外加法乘法的写法最好记下来，现场口胡老是写错细节。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, m, a[85][85];
inline int max(int a, int b) { return a &gt; b ? a : b; }
inline int bit(int x) {
    int ans = 0;
    for (; x; x /= 10) ans++;
    return ans;
}
struct integer {
    int a[7], n;
    integer(int x = 0) {
        memset(a, 0, sizeof a);
        if (!x) { n = 1; return; }
        for (int i = 1; x; x /= (int)1e8, i++) a[i] = x % (int)1e8, n = i;
    }
    inline int&amp; operator [] (const int &amp;idx) { return a[idx]; }
    inline bool operator &lt; (integer b) const {
        if (((n - 1) * 8 + bit(a[n])) ^ ((b.n - 1) * 8 + bit(b[n]))) return ((n - 1) * 8 + bit(a[n])) &lt; ((b.n - 1) * 8 + bit(b[n]));
        for (int i = n; i &gt;= 1; i--)
            if (a[i] ^ b[i]) return a[i] &lt; b[i];
        return false;
    }
    inline integer operator + (integer b) {
        integer ans;
        for (int i = 1; i &lt;= max(n, b.n); i++) {
            ans[i + 1] += (ans[i] + a[i] + b[i]) / (int)1e8;
            ans[i] = (ans[i] + a[i] + b[i]) % (int)1e8;
        }
        ans.n = max(n, b.n);
        while (ans[ans.n + 1]) ans.n++;
        return ans;
    }
    inline integer operator * (integer b) {
        integer ans;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= b.n; j++) {
                ans[i + j] += (ans[i + j - 1] + (long long)a[i] * b[j]) / (int)1e8;
                ans[i + j - 1] = (ans[i + j - 1] + (long long)a[i] * b[j] % (int)1e8) % (int)1e8;
            }
        ans.n = n + b.n - 1;
        while (ans[ans.n + 1]) ans.n++;
        return ans;
    }
    inline void print() {
        bool fst = true;
        if (!n) printf(&quot;0&quot;);
        for (int i = n; i &gt;= 1; i--) {
            if (fst) printf(&quot;%d&quot;, a[i]), fst = false;
            else printf(&quot;%08d&quot;, a[i]);
        }
        printf(&quot;\n&quot;);
    }
}int2(2), dp[85][85][85], ans;

inline integer pwr(integer x, int k) {
    integer ans(1);
    for (; k; x = x * x, k &gt;&gt;= 1)
        if (k &amp; 1) ans = ans * x;
    return ans;
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;a[i][j]);
    for (int x = 1; x &lt;= n; x++)
        for (int l = m - 1; l &gt;= 0; l--)
            for (int i = 1; i + l - 1 &lt;= m; i++) {
                int j = i + l - 1, t = m - l;
                integer s;
                if (i &gt; 1) {
                    s = dp[x][i - 1][j] + *(new integer(a[x][i - 1])) * pwr(int2, t);
                    if (dp[x][i][j] &lt; s) dp[x][i][j] = s;
                }
                if (j &lt; m) {
                    s = dp[x][i][j + 1] + *(new integer(a[x][j + 1])) * pwr(int2, t);
                    if (dp[x][i][j] &lt; s) dp[x][i][j] = s;
                }
            }
    for (int x = 1; x &lt;= n; x++) {
        integer s;
        for (int i = 1; i &lt;= m; i++)
            if (s &lt; dp[x][i][i - 1]) s = dp[x][i][i - 1];
        ans = ans + s;
    }
    ans.print();
    return 0;
}</code></pre>
<h4 id="多人背包">多人背包</h4>
<p><a href="https://www.luogu.com.cn/problem/P1858">https://www.luogu.com.cn/problem/P1858</a></p>
<p>背包九讲里讲得挺透彻的。一般求 DP 的前 k 优解，可以多开一维表示这个状态的第 k 优解，然后考虑这个状态由哪些状态转移来，由于多开的这一维对应存的值大小是递增的，所以可以用类似归并排序的方法合并那些数组，复杂度会乘上一个 k 。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int k, m, n, dp[2][5010][55], v[210], w[210], ans;

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;k, &amp;m, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;v[i], &amp;w[i]);
    for (int j = m; j &gt;= 0; j--)
        for (int p = 1; p &lt;= k; p++) dp[1][j][p] = -0x3fffffff;
    dp[1][0][1] = 0;
    int cur = 0;
    for (int i = 1; i &lt;= n; i++, cur ^= 1) {
        for (int j = m; j &gt;= 0; j--) {
            int cur1 = 1, cur2 = 1;
            for (int p = 1; p &lt;= k; p++) {
                if (j &gt;= v[i]) {
                    if (dp[cur ^ 1][j][cur1] &gt; dp[cur ^ 1][j - v[i]][cur2] + w[i]) dp[cur][j][p] = dp[cur ^ 1][j][cur1], cur1++;
                    else dp[cur][j][p] = dp[cur ^ 1][j - v[i]][cur2] + w[i], cur2++;
                }
                else dp[cur][j][p] = dp[cur ^ 1][j][p];
            }
        }
    }
    for (int i = 1; i &lt;= k; i++) ans += dp[cur ^ 1][m][i];
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="打砖块">打砖块</h4>
<p><a href="https://www.luogu.com.cn/problem/P1174">https://www.luogu.com.cn/problem/P1174</a></p>
<h4 id="低价购买">低价购买</h4>
<p><a href="https://www.luogu.com.cn/problem/P1108">https://www.luogu.com.cn/problem/P1108</a></p>
<p>求最长下降子序列长度和方案数。设$f[i]$表示以 i 结尾的最长下降子序列长度，$g[i]$表示最长下降子序列的方案数。</p>
<p>仍然使用$O(n^2)$的朴素 DP 做法，对于每个 i ，枚举 i 前面的位置 j，若$a[j]&gt;a[i]$则可以转移。两种方案相同的条件是构成相同，而不是位置相同，所以还需要去重。</p>
<p>考虑 i 前面的某个位置 j ，如果$a[j]=a[i]$，那么如果$f[j]&lt;f[i]$，显然 j 不如 i 优，对 i 后面的位置都没有贡献，所以可以直接把 j 位置清空；如果$f[j]=f[i]$，那么以 j 结尾和以 i 结尾的最长下降子序列的构成一定相同，所以也要把 j 位置清空；而$f[j]&gt;f[i]$这种情况不存在。综上所述，当 i 前面有位置 j 使得$a[j]=a[i]$时，可以直接把 j 位置清空，这样就满足了去重的要求。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int n, a[5010], f[5010], g[5010], ans1, ans2;

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    for (int i = 1; i &lt;= n; i++) {
        f[i] = g[i] = 1;
        for (int j = 1; j &lt; i; j++) {
            if (a[j] &gt; a[i]) {
                if (f[j] + 1 &gt; f[i]) {
                    f[i] = f[j] + 1;
                    g[i] = g[j];
                }
                else if (f[j] + 1 == f[i]) g[i] += g[j];
            }
            else if (a[j] == a[i]) f[j] = g[j] = 0;
        }
    }
    for (int i = 1; i &lt;= n; i++) {
        if (f[i] &gt; ans1) { ans1 = f[i], ans2 = g[i]; }
        else if (f[i] == ans1) { ans2 += g[i]; }
    }
    printf(&quot;%d %d\n&quot;, ans1, ans2);
    return 0;
}</code></pre>
<h4 id="ioi1998polygon">[IOI1998]Polygon</h4>
<p><a href="https://www.luogu.com.cn/problem/P4342">https://www.luogu.com.cn/problem/P4342</a></p>
<p>显然是一个区间 DP，要求的是最大值，但因为乘法负负得正，所以最大值也可能由两个负数最小值相乘转移得出。因此可以设$f[i][j]$表示区间$[i,j]$合并出的最大值，$g[i][j]$表示最小值，然后分各种情况讨论即可。</p>
<p>注意 f 和 g 分别要初始化为$-\inf$和$\inf$。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;

int n, a[110], f[110][110], g[110][110], ans = -0x3fffffff;
char op[110];
std::vector&lt;int&gt; ans2;

inline char readchar() {
    char c = getchar();
    while (c == &#39; &#39; || c == &#39;\n&#39; || c == &#39;\r&#39;) c = getchar();
    return c;
}
inline int min(int a, int b) { return a &lt; b ? a : b; }
inline int max(int a, int b) { return a &gt; b ? a : b; }

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) op[i] = readchar(), scanf(&quot;%d&quot;, &amp;a[i]), op[n + i] = op[i], a[n + i] = a[i];
    memset(f, -0x3f, sizeof f); memset(g, 0x3f, sizeof g);
    for (int i = 1; i &lt;= n + n; i++) f[i][i] = g[i][i] = a[i];
    for (int l = 1; l &lt;= n; l++)
        for (int i = 1; i + l - 1 &lt;= n + n; i++) {
            int j = i + l - 1;
            for (int k = i; k &lt; j; k++) {
                if (op[k + 1] == &#39;t&#39;) {
                    f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j]);
                    g[i][j] = min(g[i][j], g[i][k] + g[k + 1][j]);
                }
                else if (op[k + 1] == &#39;x&#39;) {
                    f[i][j] = max(f[i][j], f[i][k] * f[k + 1][j]);
                    f[i][j] = max(f[i][j], g[i][k] * g[k + 1][j]);
                    g[i][j] = min(g[i][j], g[i][k] * g[k + 1][j]);
                    g[i][j] = min(g[i][j], f[i][k] * g[k + 1][j]);
                    g[i][j] = min(g[i][j], g[i][k] * f[k + 1][j]);
                }
            }
        }
    for (int i = 1; i - 1 &lt; n; i++) ans = max(ans, f[i][i + n - 1]);
    for (int i = 1; i - 1 &lt; n; i++)
        if (f[i][i + n - 1] == ans) ans2.push_back(i);
    printf(&quot;%d\n&quot;, ans);
    for (std::vector&lt;int&gt;::iterator p = ans2.begin(); p != ans2.end(); p++) printf(&quot;%d &quot;, *p);
    return 0;
}</code></pre>
<h4 id="ctsc1997选课">[CTSC1997]选课</h4>
<p><a href="https://www.luogu.com.cn/problem/P2014">https://www.luogu.com.cn/problem/P2014</a></p>
<p>树上背包入门题。很久以前做过了，结果做完又忘了，所以再做一遍。设$dp[x][i]$表示以 x 为根的子树选了 i 个节点时的最大权值和，那么有：</p>
<p>$$dp[x][j]=\max_{k=1}^{j-1}(dp[x][j],dp[x][j-k]+dp[v][k])$$</p>
<p>这个方程似乎并没有体现出必须选择父节点的条件，但实际上 k 的枚举范围最大到$j-1$，就意味着当前状态无法由选了 0 个节点的状态转移来，从而满足了条件。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int n, m, dp[310][310];
struct edge { int to, next; };
struct graph {
    int ecnt, head[310];
    edge edges[310];
    inline void addedge(int u, int v) {
        edges[++ecnt].to = v;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}g;

inline int max(int a, int b) { return a &gt; b ? a : b; }
void dfs(int x) {
    for (int i = g.head[x]; i; i = g.edges[i].next) {
        int &amp;v = g.edges[i].to;
        dfs(v);
        for (int j = m; j &gt;= 1; j--)
            for (int k = 1; k &lt; j; k++) dp[x][j] = max(dp[x][j], dp[x][j - k] + dp[v][k]);
    }
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++) {
        int fa; scanf(&quot;%d%d&quot;, &amp;fa, &amp;dp[i][1]);
        g.addedge(fa, i);
    }
    m++;
    dfs(0);
    printf(&quot;%d\n&quot;, dp[0][m]);
    return 0;
}</code></pre>
<h3 id="2020-10-13">2020-10-13</h3>
<h4 id="hnoi2004敲砖块">[HNOI2004]敲砖块</h4>
<p><a href="https://www.luogu.com.cn/problem/P1437">https://www.luogu.com.cn/problem/P1437</a></p>
<p>一个砖能被敲掉的前提是它上面和右上的砖都被敲掉。所以每列被敲掉的砖一定是一个前缀。那么可以从右往左 DP ，设$dp[j][i][k]$表示处理完了后 j 列，第 j 列敲了上面 i 块砖，一共敲了 k 块砖时的最大分值。</p>
<p>$$dp[j][i][k]=\min_{l=i-1}^{n-j}(dp[j+1][l][k-i]+\sum_{p=1}^ia[i][j])$$</p>
<p>总复杂度$O(n^4)$。可以再加个前缀和优化，把$O(n)$的转移优化为$O(1)$，复杂度降到$O(n^3)$。</p>
<p>其实本质就是按照拓扑序 DP。所以其实从上往下 DP，每次枚举当前行敲了哪个前缀也是可以的。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, m, a[55][55], f[55][55][1510], g[55][55][1510], ans;

inline int max(int a, int b) { return a &gt; b ? a : b; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n - i + 1; j++) scanf(&quot;%d&quot;, &amp;a[i][j]);
    memset(f, -0x3f, sizeof f);
    f[n + 1][0][0] = g[n + 1][0][0] = 0;
    for (int j = n; j &gt;= 1; j--) {
        int sum = 0;
        for (int i = 0; i &lt;= n - j + 1; i++) {
            sum += a[i][j];
            for (int k = i * (i + 1) / 2; k &lt;= m; k++)
                f[j][i][k] = g[j + 1][max(i - 1, 0)][k - i] + sum;
            ans = max(ans, f[j][i][m]);
        }
        for (int i = n - j + 1; i &gt;= 0; i--)
            for (int k = i * (i + 1) / 2; k &lt;= m; k++) g[j][i][k] = max(g[j][i + 1][k], f[j][i][k]);
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="noi2001炮兵阵地">[NOI2001]炮兵阵地</h4>
<p><a href="https://www.luogu.com.cn/problem/P2704">https://www.luogu.com.cn/problem/P2704</a></p>
<p>状压 DP，设$dp[i][s1][s2]$表示 DP 到了第 i 行，第 i 行的状态为 s1，第 i - 1 行的状态为 s2 时，最多能放几个。如果就这样暴力 DP ，复杂度$O(8^nn)$，不太行。可以预处理满足相邻的 1 距离大于等于 2 的所有状态，然后发现这样符合条件的状态最多只有 60 个，于是复杂度就优化到了$O(60^3n)$。</p>
<p>$$dp[i][s1][s2]=\min_{valid(s3)}(dp[i-1][s2][s3]+bit(s3))$$</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, m, stt[110], scnt, dp[110][65][65], ans, a[110];

inline char read() {
    char c = getchar();
    while (c == &#39; &#39; || c == &#39;\n&#39; || c == &#39;\r&#39;) c = getchar();
    return c;
}
inline bool judge(int s) {
    int lst = -1;
    bool ok = true;
    for (int i = 0; i &lt; m &amp;&amp; ok; i++) {
        if (lst != -1 &amp;&amp; (s &amp; (1 &lt;&lt; i)) &amp;&amp; i - lst &lt;= 2) ok = false;
        else if (s &amp; (1 &lt;&lt; i))  lst = i;
    }
    return ok;
}
inline int bit(int s) {
    int ans = 0;
    for (; s; s = (s - 1) &amp; s) ans++;
    return ans;
}
inline int max(int a, int b) { return a &gt; b ? a : b; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++) {
            if (read() == &#39;H&#39;) a[i] = (a[i] &lt;&lt; 1) | 1;
            else a[i] = a[i] &lt;&lt; 1;
        }
    for (int s = 0; s &lt; (1 &lt;&lt; m); s++) if (judge(s)) stt[++scnt] = s;
    memset(dp, -0x3f, sizeof dp);
    for (int j = 1; j &lt;= scnt; j++) {
        if (stt[j] &amp; a[1]) continue;
        for (int k = 1; k &lt;= scnt; k++) {
            if (stt[j] &amp; stt[k]) continue;
            dp[1][j][k] = bit(stt[j]);
        }
    }
    for (int i = 2; i &lt;= n; i++)
        for (int j = 1; j &lt;= scnt; j++) {
            if (stt[j] &amp; a[i]) continue;
            int s = stt[j];
            for (int k = 1; k &lt;= scnt; k++) {
                if ((s &amp; stt[k]) || (stt[k] &amp; a[i - 1])) continue;
                for (int l = 1; l &lt;= scnt; l++) {
                    if ((s &amp; stt[l]) || (stt[k] &amp; stt[l]) || (stt[l] &amp; a[i - 2])) continue;
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][k][l] + bit(s));
                }
            }
        }
    for (int i = 1; i &lt;= scnt; i++) {
        if (stt[i] &amp; a[n]) continue;
        for (int j = 1; j &lt;= scnt; j++)
            if (!(stt[i] &amp; stt[j]) &amp;&amp; !(stt[j] &amp; a[n - 1])) ans = max(ans, dp[n][i][j]);
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="usaco12marcows-in-a-skyscraper-g">[USACO12MAR]Cows in a Skyscraper G</h4>
<p><a href="https://www.luogu.com.cn/problem/P3052">https://www.luogu.com.cn/problem/P3052</a></p>
<p>和之前那个机器人小 Q 类似，也是将物品划分为若干组，使得组数最小，不同的是这题对顺序没有要求，且要求全选。做法类似，让状态的 0/1 表示这个物品有没有被划分到某一组，设$f[s]$表示对应状态的最小分组数，$g[s]$表示在$f[s]$最小的前提下最后一组的最小已占用空间。然后分成可以合并到前一组和不能合并两种情况讨论即可，连分类讨论的标准都是类似的。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, w, v[20], f[270100], g[270100];

inline int min(int a, int b) { return a &lt; b ? a : b; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;w);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
    memset(f, 0x3f, sizeof f); memset(g, 0x3f, sizeof g);
    f[0] = 0;
    for (int s = 1; s &lt; (1 &lt;&lt; n); s++) {
        for (int i = 1; i &lt;= n; i++) {
            if (s &amp; (1 &lt;&lt; (i - 1))) {
                if (g[s ^ (1 &lt;&lt; (i - 1))] + v[i] &lt;= w &amp;&amp; f[s] &gt;= f[s ^ (1 &lt;&lt; (i - 1))]) {
                    f[s] = f[s ^ (1 &lt;&lt; (i - 1))];
                    g[s] = min(g[s], g[s ^ (1 &lt;&lt; (i - 1))] + v[i]);
                }
                if (g[s ^ (1 &lt;&lt; (i - 1))] + v[i] &gt; w &amp;&amp; f[s] &gt;= f[s ^ (1 &lt;&lt; (i - 1))] + 1) {
                    f[s] = f[s ^ (1 &lt;&lt; (i - 1))] + 1;
                    g[s] = min(g[s], v[i]);
                }
            }
        }
    }
    printf(&quot;%d\n&quot;, f[(1 &lt;&lt; n) - 1]);
    return 0;
}</code></pre>
<h4 id="ahoi2009中国象棋">[AHOI2009]中国象棋</h4>
<p><a href="https://www.luogu.com.cn/problem/P2051">https://www.luogu.com.cn/problem/P2051</a></p>
<p>这题我看了题解，因为想不出来怎么划分阶段和设计状态。</p>
<p>由题意得每行每列最多只能放两个棋，那么每行每列放的棋的数量只有 0, 1, 2 三种情况。可以以行为阶段进行 DP，设$dp[i][j][k]$表示前 i 行中有 j 列放了 1 个棋，k 列放了 2 个棋，剩下$m-j-k$列没有放棋。然后分情况讨论即可。</p>
<p>$$dp[i][j][k]=dp[i-1][j][k]\\+(j+1)dp[i-1][j+1][k-1]+(m-j-k+1)dp[i-1][j-1][k]\\+\binom{j+2}{2}dp[i-1][j+2][k-2]+\binom{m-j-k+2}{2}dp[i-1][j-2][k]\\+(m-j-k+1)j\cdot dp[i-1][j][k-1]$$</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

const int MOD = 9999973;
int n, m, dp[110][110][110], ans;

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    dp[0][0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 0; j &lt;= m; j++)
            for (int k = 0; k &lt;= m - j; k++) {
                dp[i][j][k] = dp[i - 1][j][k];
                if (k) dp[i][j][k] = (dp[i][j][k] + (long long)(j + 1) * dp[i - 1][j + 1][k - 1] % MOD) % MOD;
                if (j) dp[i][j][k] = (dp[i][j][k] + (long long)(m - j - k + 1) * dp[i - 1][j - 1][k] % MOD) % MOD;
                if (k &gt; 1) dp[i][j][k] = (dp[i][j][k] + (long long)(j + 2) * (j + 1) / 2 * dp[i - 1][j + 2][k - 2] % MOD) % MOD;
                if (j &gt; 1) dp[i][j][k] = (dp[i][j][k] + (long long)(m - j - k + 2) * (m - j - k + 1) / 2 * dp[i - 1][j - 2][k] % MOD) % MOD;
                if (k) dp[i][j][k] = (dp[i][j][k] + (long long)(m - j - k + 1) * j % MOD * dp[i - 1][j][k - 1] % MOD) % MOD;
            }
    for (int j = 0; j &lt;= m; j++)
        for (int k = 0; k &lt;= m - j; k++) ans = (ans + dp[n][j][k]) % MOD;
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="haoi2008糖果传递">[HAOI2008]糖果传递</h4>
<p><a href="https://www.luogu.com.cn/problem/P2512">https://www.luogu.com.cn/problem/P2512</a></p>
<p>这题我看了题解，因为没见过这种模型，弱化版(luogu P1031)也没做过。</p>
<p>设$x_i$表示第 i 个人给第 i - 1 个人传了几个唐，那么答案就是$\sum_{i=1}^n|x_i|$。题目要求最后每个人的唐数都变成$\overline a$，那么有：</p>
<p>$$a_i+x_{i+1}-x_i=\overline a(i\in[1,n])$$</p>
<p>$$x_{i+1}=\overline a-a_i+x_i$$</p>
<p>$$x_i=\overline a-a_{i-1}+x_{i-1}(i\in[1,n])$$</p>
<p>用$x_1$表示出其他的$x_i$，那么有：</p>
<p>$$x_i=\begin{cases}x_1&amp;i=1\\x_{i-1}+\overline a-a_{i-1}&amp;i\in[2,n]\end{cases}$$</p>
<p>$$x_i=\begin{cases}x_1&amp;i=1\\x_1+\sum_{j=1}^{i-1}(\overline a-a_j)&amp;i\in[2,n]\end{cases}$$</p>
<p>设</p>
<p>$$c_i=\begin{cases}0&amp;i=1\\\sum_{j=1}^{i-1}(a_j-\overline a)&amp;i\in[2,n]\end{cases}$$</p>
<p>所以</p>
<p>$$x_i=\begin{cases}x_1&amp;i=1\\x_1-c_i&amp;i\in[2,n]\end{cases}$$</p>
<p>于是答案为</p>
<p>$$\sum_{i=1}^n|x_i|=\sum_{i=1}^n|x_1-c_i|$$</p>
<p>这里还用到一个结论：设 a 是一个长度为 n 的序列，则令$\sum_{i=1}^n|x-a_i|$最小的 x 是这个序列的中位数。<del>证明略</del></p>
<p>所以可以计算一下 c 数组，然后找到 c 的中位数，然后统计答案即可。</p>
<p>注意要开long long。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

int n;
long long a[1000100], avg, c[1000100], mid, ans;

inline long long abs(long long x) { return x &gt; 0 ? x : -x; }

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), avg += a[i];
    avg /= n;
    for (int i = 1; i &lt;= n; i++) a[i] -= avg, c[i] = c[i - 1] + a[i - 1];
    std::nth_element(c + 1, c + n / 2 + 1, c + n + 1);
    mid = c[n / 2 + 1];
    if (n % 2) {
        std::nth_element(c + 1, c + n / 2, c + n + 1);
        mid = (mid + c[n / 2]) / 2;
    }
    for (int i = 1; i &lt;= n; i++) ans += abs(mid - c[i]);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="coci2013-20141-lopov">[COCI2013-2014#1] LOPOV</h4>
<p><a href="https://www.luogu.com.cn/problem/P6538">https://www.luogu.com.cn/problem/P6538</a></p>
<p>看到这个题，我不禁想到了二分图最大权匹配，但是复杂度显然不行。可以把袋子排一遍序，那么做法就变得显然了，从小到大考虑每个袋子，显然贪心地装它能装的价值最大的物品即可。</p>
<p>所以有时候给数据排个序或许能让问题变得简单。至少能方便思考。</p>
<p>注意用<code>multiset</code>，而不是<code>set</code>。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;functional&gt;

int n, k, c[300100];
long long ans;
struct item {
    int m, v;
}itm[300100];
std::multiset&lt;int, std::greater&lt;int&gt; &gt; s;

inline bool cmp(item &amp;a, item &amp;b) { return a.m &lt; b.m; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;itm[i].m, &amp;itm[i].v);
    for (int i = 1; i &lt;= k; i++) scanf(&quot;%d&quot;, &amp;c[i]);
    std::sort(itm + 1, itm + n + 1, cmp);
    std::sort(c + 1, c + k + 1);
    int cur = 1;
    for (int i = 1; i &lt;= k; i++) {
        while (cur &lt;= n &amp;&amp; itm[cur].m &lt;= c[i]) s.insert(itm[cur].v), cur++;
        if (!s.empty()) {
            ans += *s.begin();
            s.erase(s.begin());
        }
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="crci2007-2008-kuhar">[CRCI2007-2008] KUHAR</h4>
<p><a href="https://www.luogu.com.cn/problem/P6508">https://www.luogu.com.cn/problem/P6508</a></p>
<p>显然是二分，问题在于 check 函数怎么写。我想了个 DP，但是复杂度爆炸，一看题解发现原来自己写 DP 写傻了，直接枚举小包买了几个，算出要花多少钱，取最小值即可。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int n, m, a[110], b[110], sm[110], pm[110], sv[110], pv[110], suma;

inline int min(int a, int b) { return a &lt; b ? a : b; }
bool check(int mid) {
    int reqm = 0;
    for (int i = 1; i &lt;= n; i++) {
        int ireq = a[i] * mid - b[i], ireqm = 0x3fffffff;
        for (int j = 0; sm[i] * j &lt;= ireq; j++) {
            int k = (ireq - sm[i] * j) / sv[i] + ((ireq - sm[i] * j) % sv[i] ? 1 : 0);
            ireqm = min(ireqm, j * pm[i] + k * pv[i]);
        }
        ireqm = min(ireqm, (ireq / sm[i] + (ireq % sm[i] ? 1 : 0)) * pm[i]);
        if (ireqm ^ 0x3fffffff) reqm += ireqm;
    }
    return reqm &lt;= m;
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d%d%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;sm[i], &amp;pm[i], &amp;sv[i], &amp;pv[i]), suma += a[i];
    int l = 0, r = suma + m;
    while (l &lt; r) {
        int mid = l + (r - l &gt;&gt; 1);
        if (check(mid)) l = mid + 1;
        else r = mid;
    }
    printf(&quot;%d\n&quot;, l - 1);
    return 0;
}</code></pre>
<h3 id="2020-10-14">2020-10-14</h3>
<h4 id="摆渡车">摆渡车</h4>
<p><a href="https://www.luogu.com.cn/problem/P5017">https://www.luogu.com.cn/problem/P5017</a></p>
<p>显然可以看出一个复杂度关于 t 的 DP 做法，设$dp[i]$表示车在第 i 时刻出发时的最小等待时间和，那么有：</p>
<p>$$dp[i]=\min_{j=0}^{i-m}(dp[j]+i\cdot cnt(j,i)-sum(j,i))$$</p>
<p>其中 j 是枚举上一次出发的时刻，$cnt(j,i)$表示满足$j\le t_k\le i$的人数，$sum(j,i)$表示满足$j\le t_k\le i$的人的$t_k$之和。总复杂度$O(t^2)$，不行。</p>
<p>当$j\le i-2m$时，可以在$[j+m,i-m]$之间再出发一次，这样答案显然会比再$i-2m$之前出发更优，所以可以优化一下：</p>
<p>$$dp[i]=\min_{j=i-2m+1}^{i-m}(dp[j]+i\cdot cnt(j,i)-sum(j,i))$$</p>
<p>这样复杂度就优化到了$O(tm)$，有可能能过，但感觉还是不太行。</p>
<p>当$(i-m,i)$中间一个人都没有时，显然在$i-m$时刻发车比在 i 时刻发车更优，所以没有人时，$dp[i]=dp[i-m]$。</p>
<p>显然有人的状态只有$O(nm)$个，那么复杂度优化到了$O(nm^2+t)$，行。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, m, cnt[4001000], sum[4001000], maxt, dp[4001000], ans = 0x7fffffff;

inline int min(int a, int b) { return a &lt; b ? a : b; }
inline int max(int a, int b) { return a &gt; b ? a : b; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++) {
        int x; scanf(&quot;%d&quot;, &amp;x);
        cnt[x]++; sum[x] += x;
        maxt = max(maxt, x);
    }
    for (int i = 1; i &lt; maxt + m; i++) cnt[i] += cnt[i - 1], sum[i] += sum[i - 1];
    memset(dp, 0x3f, sizeof dp);
    dp[0] = 0;
    for (int i = 1; i &lt; maxt + m; i++) {
        if (i &gt;= m &amp;&amp; !(cnt[i] - cnt[i - m])) { dp[i] = dp[i - m]; continue; }
        dp[i] = i * cnt[i] - sum[i];
        for (int j = max(0, i - m - m + 1); j &lt;= i - m; j++) dp[i] = min(dp[i], dp[j] + i * (cnt[i] - cnt[j]) - (sum[i] - sum[j]));
    }
    for (int i = maxt; i &lt; maxt + m; i++) ans = min(ans, dp[i]);
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="加工零件">加工零件</h4>
<p><a href="https://www.luogu.com.cn/problem/P5663">https://www.luogu.com.cn/problem/P5663</a></p>
<p>给出一个点，每次询问某个点到这个点是否存在一条长度为 l 的路径，路径可以是简单或不简单的。</p>
<p>因为可以是不简单路径，所以只要一个点有到其他点的边，就可以先从这个点从到另一个点，再走回来，这样路径长度 +2 ，起点不变。所以可以直接跑一遍 bfs，求出给出的起点到其他所有点的长度分别为奇数和偶数的最短路，如果和 l 的奇偶性相同的最短路的长度小于等于 l ,就存在一条长度为 l 的路径。</p>
<p>这题我看了题解，原因是对这类题的模型不够了解，并且对题目的分析也不够，没想到可以走到其他点再走回来。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;utility&gt;

int n, m, t, dis[100100][2];
bool vis[100100][2];
struct edge { int to, next; };
struct graph {
    int ecnt, head[100100];
    edge edges[200100];
    inline void addedge(int u, int v) {
        edges[++ecnt].to = v;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}g;
std::queue&lt;std::pair&lt;int, int&gt; &gt; q;

void bfs() {
    memset(dis, 0x3f, sizeof dis);
    dis[1][0] = 0;
    q.push(std::make_pair(1, 0));
    while (!q.empty()) {
        std::pair&lt;int, int&gt; f = q.front();
        q.pop();
        if (vis[f.first][f.second &amp; 1]) continue;
        vis[f.first][f.second &amp; 1] = true;
        for (int i = g.head[f.first]; i; i = g.edges[i].next) {
            int &amp;v = g.edges[i].to;
            if (dis[v][(f.second &amp; 1) ^ 1] &gt; dis[f.first][f.second &amp; 1] + 1) {
                dis[v][(f.second &amp; 1) ^ 1] = dis[f.first][f.second &amp; 1] + 1;
                q.push(std::make_pair(v, dis[f.first][f.second &amp; 1] + 1));
            }
        }
    }
}

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);
    for (int i = 1; i &lt;= m; i++) {
        int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        g.addedge(u, v); g.addedge(v, u);
    }
    bfs();
    for (int i = 1; i &lt;= t; i++) {
        int a, l; scanf(&quot;%d%d&quot;, &amp;a, &amp;l);
        if (dis[a][l &amp; 1] &lt;= l) printf(&quot;Yes\n&quot;);
        else printf(&quot;No\n&quot;);
    }
    return 0;
}</code></pre>
<h4 id="宝藏">宝藏</h4>
<p><a href="https://www.luogu.com.cn/problem/P3959">https://www.luogu.com.cn/problem/P3959</a></p>
<p>n 很小，那肯定是状压 DP 。考虑状态 s 表示对应节点有没有加入生成树，但这样难以划分状态，也不知道深度是多少。可以再加一维，$dp[d][s]$表示加入状态为 s ，生成树中深度最大的点的深度为 i 时的最小花费，那么有：</p>
<p>$$dp[d][s]=\min_{(s1\in s)\land(s\in ex[s1])}(dp[d-1][s1]+(d-1)cost[s1][s])$$</p>
<p>其中$cost[s1][s]$表示在状态 s1 基础上一步(即加入的边有一端在原集合中)加入一些点变成 s 所需的最小花费，$ex[s]$表示把所有一步能加入的点都加入 s 后得到的集合。这个方程看起来不是很对，因为它把枚举的所有点都加到深度最大的点下面去了，但实际上它已经枚举了所有的方案，所以一定枚举到了最优解，而只需要保证能枚举到最优解就够了，不需要管其他不优的决策。其实这样的等价转换在之前那道 USACO 的状压题中也有体现。</p>
<p>要计算$cost$，可以把它分开考虑，考虑状态 s 一步加入某个点所需的最小花费，这个显然很好算，算出来后枚举两个状态，把所有只在其中一个集合中存在的元素的值加上即可。</p>
<p>总复杂度$O(n^23^n)$。</p>
<p>注意特判只有一个点的情况。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, m, dp[15][4100], ex[4100], dis[4100][15], cost[4100][4100], g[15][15], ans = 0x3fffffff;

inline int min(int a, int b) { return a &lt; b ? a : b; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(g, 0x3f, sizeof g);
    for (int i = 1; i &lt;= m; i++) {
        int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
        g[u][v] = g[v][u] = min(g[u][v], w);
    }
    memset(dis, 0x3f, sizeof dis);
    for (int s = 1; s &lt; (1 &lt;&lt; n); s++)
        for (int x = 1; x &lt;= n; x++)
            if (s &amp; (1 &lt;&lt; (x - 1))) {
                ex[s] |= (1 &lt;&lt; (x - 1));
                for (int v = 1; v &lt;= n; v++)
                    if (g[x][v] ^ 0x3f3f3f3f) ex[s] |= (1 &lt;&lt; (v - 1)), dis[s][v] = min(dis[s][v], g[x][v]);
            }
    for (int s = 1; s &lt; (1 &lt;&lt; n); s++)
        for (int s1 = s; s1; s1 = (s1 - 1) &amp; s)
            for (int x = 1; x &lt;= n; x++)
                if ((s &amp; (1 &lt;&lt; (x - 1))) &amp;&amp; !(s1 &amp; (1 &lt;&lt; (x - 1)))) cost[s1][s] += dis[s1][x];
    for (int root = 1; root &lt;= n; root++) {
        memset(dp, 0x3f, sizeof dp);
        dp[1][1 &lt;&lt; (root - 1)] = 0;
        for (int d = 2; d &lt;= n; d++) {
            for (int s = 0; s &lt; (1 &lt;&lt; n); s++)
                for (int s1 = s; s1; s1 = (s1 - 1) &amp; s)
                    if ((ex[s1] &amp; s) == s) dp[d][s] = min(dp[d][s], dp[d - 1][s1] + (d - 1) * cost[s1][s]);
            ans = min(ans, dp[d][(1 &lt;&lt; n) - 1]);
        }
    }
    if (n &gt; 1) printf(&quot;%d\n&quot;, ans);
    else printf(&quot;0\n&quot;);
    return 0;
}</code></pre>
<h4 id="愤怒的小鸟">愤怒的小鸟</h4>
<p><a href="https://www.luogu.com.cn/problem/P2831">https://www.luogu.com.cn/problem/P2831</a></p>
<p>n 这么小，肯定也是状压 DP，设状态 s 表示对应的猪有没有被消灭，$dp[s]$表示达到对应状态最少要发射几次。可以预处理$eft[i][j]$表示发射一条经过点 i 和点 j 的抛物线时能消灭的猪的集合。然后对于每个状态枚举单独消灭某个猪和同时消灭一些猪两种决策，后者可以枚举抛物线经过的两个点。这样总复杂度是$O(2^nn^2)$的，感觉不太行。</p>
<p>交换消灭的顺序，对答案是没有影响的。所以，对于当前状态中的某个点，既然它迟早要被消灭，那现在就消灭它好了。所以可以固定状态的一个点(比如我写的是编号最小的点)，然后枚举另一个点即可，总复杂度优化到了$O(2^nn)$，行。</p>
<p>这题我看了题解，设计出状态后没想出来怎么预处理和写方程，对模型的了解还不够，总之不够熟练。我觉得可能可以这样思考：既然要消灭若干猪，那可以枚举其中的两个，因为三点确定抛物线，所以枚举两个足以推出其他的。从小的部分入手。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

const double eps = 1e-6;
int t, n, m, dp[270100], lowbitx[270100], eft[20][20];
double x[20], y[20];

inline double abs(double x) { return x &gt; -eps ? x : -x; }
inline int min(int a, int b) { return a &lt; b ? a : b; }

int main() {
    scanf(&quot;%d&quot;, &amp;t);
    while (t--) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i++) scanf(&quot;%lf %lf&quot;, &amp;x[i], &amp;y[i]);
        for (int s = 1; s &lt; (1 &lt;&lt; n); s++) {
            int t = s, x = 1;
            while (!(t &amp; 1)) t &gt;&gt;= 1, x++;
            lowbitx[s] = x;
        }
        memset(eft, 0, sizeof eft);
        for (int i = 1; i &lt;= n; i++)
            for (int j = i + 1; j &lt;= n; j++) {
                if (abs(x[i] - x[j]) &lt; eps) continue;
                double a = (y[i] * x[j] - y[j] * x[i]) / (x[i] * x[i] * x[j] - x[j] * x[j] * x[i]), b = y[i] / x[i] - a * x[i];
                if (a &gt; 0) continue;
                for (int k = 1; k &lt;= n; k++)
                    if (abs(a * x[k] * x[k] + b * x[k] - y[k]) &lt; eps) eft[i][j] = eft[j][i] = (eft[i][j] | (1 &lt;&lt; (k - 1)));
            }
        memset(dp, 0x3f, sizeof dp);
        dp[0] = 0;
        for (int s = 1; s &lt; (1 &lt;&lt; n); s++) {
            for (int i = 1; i &lt;= n; i++) {
                dp[s] = min(dp[s], dp[s ^ (1 &lt;&lt; (i - 1))] + 1);
                dp[s] = min(dp[s], dp[s ^ (eft[i][lowbitx[s]] &amp; s)] + 1);
            }
        }
        printf(&quot;%d\n&quot;, dp[(1 &lt;&lt; n) - 1]);
    }
    return 0;
}</code></pre>
<h4 id="zjoi2007时态同步">[ZJOI2007]时态同步</h4>
<p><a href="https://www.luogu.com.cn/problem/P1131">https://www.luogu.com.cn/problem/P1131</a></p>
<p>可以考虑把过程倒过来，从所有叶子节点出发，同时汇聚到根节点，那么对于每个点，叶子节点的电流一定是同时到达它的，于是做法显而易见：记某个点 x 的所有叶子节点到达它的最早时间是$t[x]$，对于每个节点求子节点的 t 的最大值 maxt，maxt 减去每个子节点的 t 就是这个子节点对答案的贡献。</p>
<p>这题我看了题解，没有想到倒过来做。正难则反，有时候把过程倒过来想说不定就变简单了。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int n, s;
long long t[500100], ans;
struct edge { int to, next, w; };
struct graph {
    int ecnt = 1, head[500100];
    edge edges[1000100];
    inline void addedge(int u, int v, int w) {
        edges[++ecnt].to = v;
        edges[ecnt].w = w;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}g;

inline int max(int a, int b) { return a &gt; b ? a : b; }

void dfs(int x, int lst) {
    for (int i = g.head[x]; i; i = g.edges[i].next) {
        if ((i ^ lst) == 1) continue;
        int &amp;v = g.edges[i].to;
        dfs(v, i);
        t[x] = max(t[x], t[v] + g.edges[i].w);
    }
    for (int i = g.head[x]; i; i = g.edges[i].next) {
        if ((i ^ lst) == 1) continue;
        ans += t[x] - t[g.edges[i].to] - g.edges[i].w;
    }
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;s);
    for (int i = 1; i &lt; n; i++) {
        int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
        g.addedge(u, v, w); g.addedge(v, u, w);
    }
    dfs(s, 0);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="pa2014pakowanie">[PA2014]Pakowanie</h4>
<p><a href="https://www.luogu.com.cn/problem/P5997">https://www.luogu.com.cn/problem/P5997</a></p>
<p>又是一个最小划分组数问题，这次不同组的容量是不同的。优先选择容量更大的包更优，所以可以先把包排序，然后和前面两题一样 DP 即可。</p>
<p>注意判断一些边界条件，不要一时图快就赶紧交了。</p>
<p>这题我看了题解，没想到贪心选大包，对状压 DP 的认识也不够深，实际上，这样做能够枚举所有的方案，所以是对的。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;

int n, m, v[30], c[110], f[17001000], g[17001000];

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
    for (int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;c[i]);
    std::sort(c + 1, c + m + 1, std::greater&lt;int&gt;());
    memset(f, 0x3f, sizeof f); memset(g, 0x3f, sizeof g);
    f[0] = 0;
    for (int s = 1; s &lt; (1 &lt;&lt; n); s++)
        for (int i = 1; i &lt;= n; i++)
            if (s &amp; (1 &lt;&lt; (i - 1))) {
                int s1 = s ^ (1 &lt;&lt; (i - 1));
                if (f[s1] &gt; n) continue;
                if (g[s1] + v[i] &lt;= c[f[s1]]) {
                    if (f[s] &gt; f[s1]) f[s] = f[s1], g[s] = g[s1] + v[i];
                    else if (f[s] == f[s1] &amp;&amp; g[s1] + v[i] &lt; g[s]) g[s] = g[s1] + v[i];
                }
                else {
                    if (v[i] &gt; c[f[s1] + 1]) continue;
                    if (f[s] &gt; f[s1] + 1) f[s] = f[s1] + 1, g[s] = v[i];
                    else if (f[s] == f[s1] + 1 &amp;&amp; v[i] &lt; g[s]) g[s] = v[i];
                }
            }
    if (f[(1 &lt;&lt; n) - 1] ^ 0x3f3f3f3f) printf(&quot;%d\n&quot;, f[(1 &lt;&lt; n) - 1]);
    else printf(&quot;NIE\n&quot;);
    return 0;
}</code></pre>
<h3 id="2020-10-15">2020-10-15</h3>
<h4 id="火柴排队">火柴排队</h4>
<p> <a href="https://www.luogu.com.cn/problem/P1966">https://www.luogu.com.cn/problem/P1966</a></p>
<p>$$\sum_{i=1}^n(a_i-b_i)^2=\sum_{i=1}^n(a_i^2+b_i^2)-2\sum_{i=1}^na_ib_i$$</p>
<p>不管怎么交换，其中的$\sum(a_i^2+b_i^2)$的值都不会变化，那么问题就转化为了$\sum a_ib_i$最大。</p>
<p>由排序不等式得，当序列 a 与序列 b 中大小排名相同的数放在同一位置时，$\sum a_ib_i$最大。所以可以先把两个序列离散化一下，然后要求的就是把排列 b 变成排列 a 的最小交换次数，可以将 a 中的数字按照位置重新编号，将 b 按照相同的规则重新改写，然后求 b 的逆序对个数即可。</p>
<p>这题我看了题解，看题解前用贪心的邻项交换法整了个奇怪的式子，可以用来排序并求出最小距离和，但不能求出最小交换次数。没想到可以求逆序对个数。总之分析题目时最好先推一下题目中直接出现的式子，而不要用一些与题目没有显然关联的方法分析，另外看到最小交换次数就要反应过来一般是逆序对个数。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

const int MOD = 1e8 - 3;
int n, a[100100], b[100100], c[100100], d[100100], ans;
struct ft {
    int ft[100100];
    inline int lowbit(int x) { return x &amp; -x; }
    inline void add(int x, int v) { for (x = n - x + 1; x &lt;= n; x += lowbit(x)) ft[x] += v; }
    inline int query(int x) {
        int ans = 0;
        for (x = n - x + 1; x &gt;= 1; x -= lowbit(x)) ans += ft[x];
        return ans;
    }
}ft;

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), c[i] = a[i];
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b[i]);
    std::sort(c + 1, c + n + 1);
    int an = std::unique(c + 1, c + n + 1) - c - 1;
    for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(c + 1, c + an + 1, a[i]) - c;
    for (int i = 1; i &lt;= n; i++) c[i] = b[i];
    std::sort(c + 1, c + n + 1);
    int bn = std::unique(c + 1, c + n + 1) - c - 1;
    for (int i = 1; i &lt;= n; i++) b[i] = std::lower_bound(c + 1, c + bn + 1, b[i]) - c;
    for (int i = 1; i &lt;= n; i++) d[a[i]] = i;
    for (int i = 1; i &lt;= n; i++) b[i] = d[b[i]];
    for (int i = 1; i &lt;= n; i++) {
        ans = (ans + ft.query(b[i])) % MOD;
        ft.add(b[i], 1);
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<h4 id="解方程">解方程</h4>
<p><a href="https://www.luogu.com.cn/problem/P2312">https://www.luogu.com.cn/problem/P2312</a></p>
<p>一看这数据范围好像要写高精，但是感觉复杂度不太行，一看题解，原来是哈希。枚举所有可能的解，然后计算验证，因为系数太大所以可以模一个数(我膜的是 19260817)，如果在模这个数意义下计算出多项式是 0 那么就假装它是解。这样做大概率是对的，可以多模几个数提高正确率，不过常数也会增加，我写了两个模数就 TLE 了。</p>
<p>计算多项式可以用秦九韶算法。</p>
<p>另外，还可以取小质数为模数，然后如果一个数不是解，那么这个数加模数的倍数也不是解，从而降低常数。听说还可以用中国剩余定理优化，但是好像没有题解这样写。</p>
<p>这题我看了题解，因为没想到可以用哈希做，总之不会做时可以想一些奇怪的乱搞做法，比如哈希。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

const int MOD = 19260817;

int n, m, a[110], ans1, ans2[1000100];

inline void read(int x) {
    register char ch = getchar();
    register int flag = 1;
    while (ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39;) ch = getchar();
    if (ch == &#39;-&#39;) flag = -1, ch = getchar();
    while (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;) {
        a[x] = ((long long)a[x] * 10 + (ch &amp; 15) * flag + MOD) % MOD;
        ch = getchar();
    }
}
inline bool check(int x) {
    int ans = a[n];
    for (int i = n; i &gt;= 1; i--) ans = ((long long)ans * x + a[i - 1]) % MOD;
    return !ans;
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt;= n; i++) read(i);
    for (int x = 1; x &lt;= m; x++)
        if (check(x)) ans2[++ans1] = x;
    printf(&quot;%d\n&quot;, ans1);
    for (int i = 1; i &lt;= ans1; i++) printf(&quot;%d\n&quot;, ans2[i]);
    return 0;
}</code></pre>
<h4 id="传球游戏">传球游戏</h4>
<p><a href="https://www.luogu.com.cn/problem/P5888">https://www.luogu.com.cn/problem/P5888</a></p>
<p>受到限制的节点最多只有 1e5 个，那么可以把所有不被限制且不是第一个点的点合并在一起，记为 0 号节点。设$dp[i][j]$表示传了 i 次球最后传到了 j 的方案数，直接 DP 即可。</p>
<p>这样暴力 DP 复杂度是$O(mk^2)$的，因为需要$O(k)$转移。正难则反，可以预处理所有节点的方案数之和$\sum_{j=0}^{vn}dp[i-1][j]$，其中 vn 是有限制的点的个数，然后用这个和减去当前点能到达的点的方案数即可，因为只有$O(k)$条边，所以复杂度降为了$O(m(k+k))$即$O(mk)$。</p>
<p>注意边是单向边。</p>
<p>这题我看了题解，因为不会优化转移。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt; 

const int MOD = 998244353;
int n, k, m, vl[100100], vcnt, dp[210][100100], sum[210];
struct uedge { int u, v; }edges[50100];
struct edge { int to, next; };
struct graph {
    int ecnt, head[100100];
    edge edges[200100];
    inline void addedge(int u, int v) {
        edges[++ecnt].to = v;
        edges[ecnt].next = head[u];
        head[u] = ecnt;
    }
}g;

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m);
    vl[++vcnt] = 1;
    for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;edges[i].u, &amp;edges[i].v), vl[++vcnt] = edges[i].u, vl[++vcnt] = edges[i].v;
    std::sort(vl + 1, vl + vcnt + 1);
    int vn = std::unique(vl + 1, vl + vcnt + 1) - vl - 1;
    for (int i = 1; i &lt;= m; i++) {
        edges[i].u = std::lower_bound(vl + 1, vl + vn + 1, edges[i].u) - vl;
        edges[i].v = std::lower_bound(vl + 1, vl + vn + 1, edges[i].v) - vl;
        g.addedge(edges[i].u, edges[i].v);
    }
    dp[0][1] = 1; sum[0] = 1;
    for (int j = 1; j &lt;= k; j++) {
        if (n - vn &gt; 0) dp[j][0] = (long long)dp[j - 1][0] * (n - vn - 1) % MOD;
        for (int i = 1; i &lt;= vn; i++) dp[j][0] = (dp[j][0] + (long long)dp[j - 1][i] * (n - vn) % MOD) % MOD;
        sum[j] = dp[j][0];
        for (int x = 1; x &lt;= vn; x++) {
            dp[j][x] = (sum[j - 1] - dp[j - 1][x] + MOD) % MOD;
            for (int i = g.head[x]; i; i = g.edges[i].next)
                if (x ^ g.edges[i].to) dp[j][x] = (dp[j][x] - dp[j - 1][g.edges[i].to] + MOD) % MOD;
            sum[j] = (sum[j] + dp[j][x]) % MOD;
        }
    }
    printf(&quot;%d\n&quot;, dp[k][1]);
    return 0;
}</code></pre>
<h4 id="迎接仪式">迎接仪式</h4>
<p><a href="https://www.luogu.com.cn/problem/P1136">https://www.luogu.com.cn/problem/P1136</a></p>
<p>显然交换两个相同的字符是没用的，交换两个不同的字符，等价于把一个从 j 变为 z ，另一个从 z 变为 j。于是可以设$dp[i][j][k][0/1]$表示前 i 个字符中有 j 个从 z 变为了 j，有 k 个从 j 变为了 z，第 i 位变为了 j / z 的最大 jz 个数，那么有：</p>
<p>$$dp[i][j][k][0]=\max(dp[i-1][j][k][0],dp[i-1][j][k][1])\ \ \ (s[i]=j)$$</p>
<p>$$dp[i][j][k][1]=\max(dp[i-1][j][k-1][0]+1,dp[i-1][j][k-1][1])\ \ \ (s[i]=j)$$</p>
<p>$$dp[i][j][k][0]=\max(dp[i-1][j-1][k][0],dp[i-1][j-1][k][1])\ \ \ (s[i]=z)$$</p>
<p>$$dp[i][j][k][1]=\max(dp[i-1][j][k][0]+1,dp[i-1][j][k][1])\ \ \ (s[i]=z)$$</p>
<p>然后记得初始化为$-\inf$，$dp[0][0][0][1]=0$。对于最优化问题的 DP，一般都要初始化为$\inf$或$-\inf$，然后一些合法的初始状态初始化为 0 或者其他什么东西，这样才能保证状态由合法的状态转移而来。总之初始化也是 DP 设计中重要的一环。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n, m, dp[510][110][110][2], ans;
char s[510];

inline int max(int a, int b) { return a &gt; b ? a : b; }

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    scanf(&quot;%s&quot;, s + 1);
    memset(dp, -0x3f, sizeof dp);
    dp[0][0][0][1] = 0;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 0; j &lt;= m; j++)
            for (int k = 0; k &lt;= m; k++) {
                if (s[i] == &#39;j&#39;) {
                    dp[i][j][k][0] = max(dp[i - 1][j][k][0], dp[i - 1][j][k][1]);
                    if (k) dp[i][j][k][1] = max(dp[i - 1][j][k - 1][0] + 1, dp[i - 1][j][k - 1][1]);
                }
                else if (s[i] == &#39;z&#39;) {
                    if (j) dp[i][j][k][0] = max(dp[i - 1][j - 1][k][0], dp[i - 1][j - 1][k][1]);
                    dp[i][j][k][1] = max(dp[i - 1][j][k][0] + 1, dp[i - 1][j][k][1]);
                }
            }
    for (int i = 0; i &lt;= m; i++) ans = max(ans, max(dp[n][i][i][0], dp[n][i][i][1]));
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
<a href="../posts.html" class="link" style="display:block; text-align:center;">return</a>
</div>
</body>
</html>