<!DOCTYPE html>
        <html>
            <head>
                <meta charset="utf-8"/>
                <title>n-kw && n-c by others</title>
                <link rel="stylesheet" type="text/css" href="../styles.css"/>
                <link rel="stylesheet" type="text/css" href="../markdownStyles.css"/>
                <script type="text/x-mathjax-config">
                    MathJax.Hub.Config({
                        extensions: ["tex2jax.js"],
                        jax: ["input/TeX", "output/HTML-CSS"],
                        tex2jax: {
                        inlineMath: [ ['$','$'] ],
                        displayMath: [ ['$$','$$'] ],
                        processEscapes: true
                        },
                        "HTML-CSS": { availableFonts: ["TeX"] }
                    });
                </script>
                <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
            </head>
            <body>
                <div class="body">
                <p class="title">striving & singing</p><p>按照计划，本周的学习重点是基础算法。</p>
<h3 id="2020-06-22">2020-06-22</h3>
<p>晚上做了一道搜索题，连同上周末做的一起写了。</p>
<h4 id="noi1999生日蛋糕">[NOI1999]生日蛋糕</h4>
<p><a href="https://www.luogu.com.cn/problem/P1731">https://www.luogu.com.cn/problem/P1731</a></p>
<p>老题了，年龄比我还大。这题就普通$\texttt{DFS}$加五个剪枝。</p>
<ol>
<li>可行性剪枝：当前已用体积$v$大于$n$则直接退出。</li>
<li>最优性剪枝：当前表面积$s$大于已知最优答案$ans$则直接退出。</li>
<li>当前表面积$s$加上之后几层的最小表面积大于已知最优答案$ans$则直接退出。</li>
</ol>
<p>要求之后几层的最小表面积，因为底面积已经固定所以只用求侧面积就好了。侧面积等于$2\pi rh$去掉共同的常数$\pi$也就是$2rh$，要使连续几层最小相当于求平方和$\sum_{i=1}^{m-x+1}2i^2$，其中$x$是目前处于的层数。根据平方和公式得出$\sum_{i=1}^{m-x+1}2i^2=\dfrac{(m-x+1)(m-x+2)(2m-2x+3)}{3}$。</p>
<ol start="4">
<li>当前体积$v$加上之后几层的最大体积小于等于$n$则直接退出。</li>
</ol>
<p>很简单不用讲。</p>
<ol start="5">
<li><code>s + (n - v) * 2 / lstr &gt; ans</code>则直接退出。</li>
</ol>
<p>由侧面积公式$s=2rh$，体积公式$v=r^2h$得出$s=\dfrac{2v}{r}$。$n-v$是剩下可用的体积，$lstr$则是上一层的半径。$v$不变，要使$s$最小，$r$要最大，最大为$lstr-1$，当然我们让此层半径再大一点大到$lstr$也无伤大雅，所以如果当前侧面积$s$加上之后几层的最小侧面积(实际上无法达到)$\dfrac{2(n-v)}{lstr}$比当前最小答案大，则直接退出。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int n, m, ans = 0x3fffffff;

inline int min(int a, int b) { return a &lt; b ? a : b; }
void dfs(int x, int lstr, int lsth, int s, int v) {
    if (x == m + 1) {
        if (v ^ n) return;
        ans = min(ans, s);
        return;
    }
    if (s &gt;= ans || v &gt;= n) return;
    if (s + (m - x + 1) * (m - x + 2) * (m * 2 - x * 2 + 3) / 3 &gt;= ans) return;
    if (v + lstr * lstr * lsth * (m - x + 1) &lt;= n) return;
    if (s + (n - v) * 2 / lstr &gt; ans) return;
    for (int r = m - x + 1; r &lt;= lstr - 1; r++)
        for (int h = m - x + 1; h &lt;= lsth - 1; h++) {
            dfs(x + 1, r, h, s + 2 * r * h, v + r * r * h);
        }
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int r = m; r * r * r &lt;= n; r++)
        for (int h = m; r * r * h &lt;= n; h++) dfs(2, r, h, r * r + 2 * r * h, r * r * h);
    if (ans ^ 0x3fffffff) printf(&quot;%d\n&quot;, ans);
    else printf(&quot;0\n&quot;);
    return 0;
}</code></pre>
<h4 id="scoi2009生日快乐">[SCOI2009]生日快乐</h4>
<p><a href="https://www.luogu.com.cn/problem/P4160">https://www.luogu.com.cn/problem/P4160</a></p>
<p>洛谷的某些题解似乎有部分错误。根据我的理解，矩形的某条边长度为$a$，要把这个矩形平均分成$x$份，则分开的长度必须是$\dfrac{a}{x}$的倍数，并不是因为面积相等，而是因为要使切出的面积为$\dfrac{xy}{n}$，则切出的矩形的两边最小分别为$\dfrac{x}{n}$和$\dfrac{y}{n}$，而要使这块大矩形切出来的小矩形长宽最小能取到$\dfrac{x}{n}$和$\dfrac{y}{n}$，则大矩形的长宽必须为其倍数。</p>
<p>按照我的习惯，$\texttt{dfs}$函数中的$x$应当表示当前在切第几块矩形，但在这题中$x$表示当前矩形需要被分成几块。</p>
<p>然后这题就做完了。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;

int n;
double a, b, ans;

inline void swap(double &amp;a, double &amp;b) { double t = a; a = b; b = t; }
inline double min(double a, double b) { return a &lt; b ? a : b; }
inline double max(double a, double b) { return a &gt; b ? a : b; }
double dfs(int x, double ax, double bx) {
    if (x == 1) {
        if (ax &lt; bx) swap(ax, bx);
        return ax / bx;
    }
    double ans = 0x3fffffff;
    for (double i = ax / x; i &lt; ax; i += ax / x)
        ans = min(ans, max(dfs(i / (ax / x), i, bx), dfs(x - i / (ax / x), ax - i, bx)));
    for (double i = bx / x; i &lt; bx; i += bx / x)
        ans = min(ans, max(dfs(i / (bx / x), ax, i), dfs(x - i / (bx / x), ax, bx - i)));
    return ans;
}

int main() {
    scanf(&quot;%lf%lf%d&quot;, &amp;a, &amp;b, &amp;n);
    printf(&quot;%.6lf\n&quot;, dfs(n, a, b));
    return 0;
}</code></pre>
<a href="../posts.html" class="link" style="display:block; text-align:center;">return</a>
</div>
</body>
</html>