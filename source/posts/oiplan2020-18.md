title: 王道征途——NOIP2020冲刺计划·第十八周(10.19~10.25)
date: 2020-10-19
weight: 20201019
<!--more-->

### 2020-10-19
#### [SCOI2009]生日礼物
https://www.luogu.com.cn/problem/P2564

一看题目显然可以双指针，那么先把坐标离散化，再记录每个坐标上的颜色，这样时间复杂度是$O(n\log n)$的，看起来可以，但是空间复杂度是$O(nk)$的，交上去直接 MLE 了。另一种更简单的方法是把珠子按照坐标排序，然后直接双指针即可，时间复杂度也是$O(n\log n)$，空间复杂度$O(n)$。

还有一种方法是先把所有颜色中坐标最小的加入堆中，然后每次取出堆中坐标最小的，把它的颜色对应的没有加入过堆的坐标最小的柱子加进去，这样复杂度是$O(n\log k)$的，更优。

```cpp
#include<cstdio>
#include<utility>
#include<algorithm>

int n, k, cnt[61], ccnt, icnt, ans = 0x7fffffff;
std::pair<int, int> itm[1000100];

inline int min(int a, int b) { return a < b ? a : b; }

int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= k; i++) {
		int t; scanf("%d", &t);
		for (int j = 1; j <= t; j++) {
			int x; scanf("%d", &x);
			itm[++icnt] = std::make_pair(x, i);
		}
	}
	std::sort(itm + 1, itm + icnt + 1);
	int cur = 1;
	for (int i = 1; i <= n; i++) {
		while (cur <= n && ccnt < k) {
			if (!cnt[itm[cur].second]) ccnt++;
			cnt[itm[cur].second]++;
			cur++;
		}
		if (ccnt == k) ans = min(ans, itm[cur - 1].first - itm[i].first);
		cnt[itm[i].second]--;
		if (!cnt[itm[i].second]) ccnt--;
	}
	printf("%d\n", ans);
	return 0;
}
```

#### [SCOI2005]最大子矩阵
https://www.luogu.com.cn/problem/P2331

一看$m\le 2$，可以直接想出一个状压 DP，设$dp[i][j][s]$表示前 i 行选了 j 个子矩阵，最后一行选的状态是 s 时的最大权值，其中状态 s 的第 k 位表示第 i 行的对应位置选没选。然后每个状态的决策有和前面的矩阵合并，和自己单独成为一个矩阵两种，分情况讨论即可。

但这样没法处理某一行中的两列属于不同的两个矩阵的情况(样例就是一个例子)，解决方法是再加一种状态，当 s = 4 时表示两个位置都选了，但属于不同的两个矩阵，然后继续分情况讨论即可。

注意分类讨论的状态转移细节，把一个 3 写成了 2 调了一个小时。

```cpp
#include<cstdio>
#include<cstring>

int n, m, k, a[110][3], dp[110][11][5], ans;

inline int max(int a, int b) { return a > b ? a : b; }

int main() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) scanf("%d", &a[i][j]);
	memset(dp, -0x3f, sizeof dp);
	dp[0][0][0] = 0;
	if (m == 1) {
		for (int i = 1; i <= n; i++)
			for (int j = 0; j <= k; j++) {
				dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1]);
				dp[i][j][1] = dp[i - 1][j][1] + a[i][1];
				if (j) dp[i][j][1] = max(dp[i][j][1], max(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1]) + a[i][1]);
			}
		ans = max(dp[n][k][0], dp[n][k][1]);
	}
	else if (m == 2) {
		for (int i = 1; i <= n; i++)
			for (int j = 0; j <= k; j++) {
				for (int lst = 0; lst <= 4; lst++) {
					dp[i][j][0] = max(dp[i][j][0], dp[i - 1][j][lst]);
					if (j) dp[i][j][1] = max(dp[i][j][1], dp[i - 1][j - 1][lst] + a[i][2]);
					if (j) dp[i][j][2] = max(dp[i][j][2], dp[i - 1][j - 1][lst] + a[i][1]);
					if (j) dp[i][j][3] = max(dp[i][j][3], dp[i - 1][j - 1][lst] + a[i][1] + a[i][2]);
					if (j >= 2) dp[i][j][4] = max(dp[i][j][4], dp[i - 1][j - 2][lst] + a[i][1] + a[i][2]);
				}
				dp[i][j][1] = max(dp[i][j][1], max(dp[i - 1][j][1], dp[i - 1][j][4]) + a[i][2]);
				dp[i][j][2] = max(dp[i][j][2], max(dp[i - 1][j][2], dp[i - 1][j][4]) + a[i][1]);
				dp[i][j][3] = max(dp[i][j][3], dp[i - 1][j][3] + a[i][1] + a[i][2]);
				dp[i][j][4] = max(dp[i][j][4], dp[i - 1][j][4] + a[i][1] + a[i][2]);
				if (j) dp[i][j][4] = max(dp[i][j][4], max(dp[i - 1][j - 1][1], dp[i - 1][j - 1][2]) + a[i][1] + a[i][2]);
			}
		for (int s = 0; s <= 4; s++) ans = max(ans, dp[n][k][s]);
	}
	printf("%d\n", ans);
	return 0;
}
```

#### [HNOI2010]合唱队
https://www.luogu.com.cn/problem/P3205

因为每次都是在序列的开头或结尾加数字，所以不难想到以区间作为阶段来 DP。设$dp[i][j][0/1]$表示区间$[i,j]$最后一次加入在了队头 / 队尾的方案数，初始化$dp[i][i][0]=dp[i][i][1]=1$，然后直接分类讨论即可。

一测样例发现输出的方案数是样例的两倍，其实是因为$dp[i][i][0]=dp[i][i][1]=1$导致只有一个人的序列方案数是 2，那么可以直接钦定一个人的序列只能从队头插入，即$dp[i][i][0]=1,dp[i][i][1]=0$。

```cpp
#include<cstdio>

const int MOD = 19650827;
int n, h[1010], dp[1010][1010][2];

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &h[i]), dp[i][i][0] = 1;
	for (int l = 2; l <= n; l++)
		for (int i = 1; i + l - 1 <= n; i++) {
			int j = i + l - 1;
			if (h[i] < h[i + 1]) dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][0]) % MOD;
			if (h[i] < h[j]) dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][1]) % MOD;
			if (h[j] > h[i]) dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][0]) % MOD;
			if (h[j] > h[j - 1]) dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][1]) % MOD;
		}
	printf("%d\n", (dp[1][n][0] + dp[1][n][1]) % MOD);
	return 0;
}
```

#### 重建道路
https://www.luogu.com.cn/problem/P1272

设$dp[x][i]$表示节点 x 保留了 i 个节点，且保留了根节点时最少需要去掉的边数，那么有：

$$dp[x][i]=\begin{cases}deg[x]-[x\not =1]&i=1\\\min_{j=0}^i\{dp[x][i-j]+dp[v][j]-1\}\end{cases}$$

其中$deg[x]$是 x 的度数，v 是节点 x 的子节点。-1 是因为在$dp[x][i-j]$中把$(x,v)$这条边删掉了，而要保留子节点就不能删这条边，所以删的边数 -1。

答案是$\min_{x=1}^n\{dp[x][s]+[x\not=1]\}$。

```cpp
#include<cstdio>
#include<cstring>

int n, s, dp[155][155], ans = 0x3fffffff, deg[155];
struct edge { int to, next; };
struct graph {
	int ecnt = 1, head[155];
	edge edges[310];
	inline void addedge(int u, int v) {
		edges[++ecnt].to = v;
		edges[ecnt].next = head[u];
		head[u] = ecnt;
	}
}g;

inline int min(int a, int b) { return a < b ? a : b; }

void dfs(int x, int lst) {
	dp[x][1] = deg[x] - (x == 1 ? 0 : 1);
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		int &v = g.edges[i].to;
		dfs(v, i);
		for (int j = s; j >= 2; j--)
			for (int k = 0; k <= j; k++) dp[x][j] = min(dp[x][j], dp[x][j - k] + dp[v][k] - 1);
	}
	ans = min(ans, dp[x][s] + (x == 1 ? 0 : 1));
}

int main() {
	scanf("%d%d", &n, &s);
	for (int i = 1; i < n; i++) {
		int u, v; scanf("%d%d", &u, &v);
		g.addedge(u, v); g.addedge(v, u);
		deg[u]++; deg[v]++;
	}
	memset(dp, 0x3f, sizeof dp);
	dfs(1, 0);
	printf("%d\n", ans);
	return 0;
}
```

#### 面基
https://www.luogu.com.cn/problem/P5628

这个是 USACO 的原题(luogu P3047)，以前做过那个原题但是现在又不太会了，所以再做一遍。为方便，下面讲的是原题的思路，本题在原题基础上稍加转化即可。

设$dp[x][i]$表示距离节点 x 距离不超过 i 的节点的权值和，那么可以先 dfs 一遍，求出距离节点 x 距离不超过 i 的 x 的子树内的节点的权值和，做法很显然，就不写了。然后可以换根+容斥，在第一遍 dfs 后，因为节点 1 是根节点所以节点 1 的 dp 值就是实际值，于是第二遍 dfs 时可以让$dp[v][i]$加上父节点的$dp[x][i-1]$，合并得到不是子树内的节点的权值和，而$dp[v][i-2]$多算了一遍所以还要减去。

```cpp
#include<cstdio>

int n, k, size[30100];
long long dp[30100][210], ans;
struct edge { int to, next, w; };
struct graph {
	int ecnt = 1, head[30100];
	edge edges[60100];
	inline void addedge(int u, int v) {
		edges[++ecnt].to = v;
		edges[ecnt].next = head[u];
		head[u] = ecnt;
	}
}g;

void dfs1(int x, int lst) {
	size[x] = 1;
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		int &v = g.edges[i].to;
		dfs1(v, i);
		size[x] += size[v];
		dp[x][0] += (long long)(n - size[v]) * size[v];
		for (int j = 1; j <= k; j++) dp[x][j] += dp[v][j - 1];
	}
	for (int j = 1; j <= k; j++) dp[x][j] += dp[x][0];
}
void dfs2(int x, int lst) {
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		int &v = g.edges[i].to;
		for (int j = k; j >= 1; j--) dp[v][j] += dp[x][j - 1] - (j >= 2 ? dp[v][j - 2] : 0);
		dp[v][0] += (long long)(n - size[v]) * size[v];
		dfs2(v, i);
	}
}
inline long long max(long long a, long long b) { return a > b ? a : b; }

int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i < n; i++) {
		int u, v; scanf("%d%d", &u, &v);
		g.addedge(u, v); g.addedge(v, u);
	}
	dfs1(1, 0);
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) ans = max(ans, dp[i][k]);
	printf("%lld\n", ans);
	return 0;
}
```

### 2020-10-20
#### 括号树
https://www.luogu.com.cn/problem/P5658

当时考场上想出了$O(n^2)$的暴力做法，但是树上的情况写挂了调不出来，于是只好写了个链的情况，拿了 35 分。要是树上的情况没写挂，拿到 50 分，那就可以省一了。

其实是一个线性 DP 强行搬到了树上。考虑链上的情况，设$dp[i]$表示以第 i 个位置结尾的合法括号序列个数，显然若$s[i]='('$或者$s[i]=')'$但没有匹配的左括号那么$dp[i]=0$，否则设匹配的左括号的位置为 lst，那么有$dp[i]=dp[lst-1]+1$。感觉挺对的，不过考场上没想出来，毕竟太菜了。

```cpp
#include<cstdio>
#include<stack>

int n, f[500100];
long long dp[500100], ans;
char s[500100];
struct edge { int to, next; };
struct graph {
	int ecnt, head[500100];
	edge edges[500100];
	inline void addedge(int u, int v) {
		edges[++ecnt].to = v;
		edges[ecnt].next = head[u];
		head[u] = ecnt;
	}
}g;
std::stack<int> stk;

void dfs1(int x) {
	int t = 0;
	if (s[x] == '(') stk.push(x);
	else if (s[x] == ')' && !stk.empty()) {
		dp[x] = dp[f[stk.top()]] + 1;
		t = stk.top(); stk.pop();
	}
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		int &v = g.edges[i].to;
		dfs1(v);
	}
	if (s[x] == '(') stk.pop();
	else if (t) stk.push(t);
}
void dfs2(int x) {
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		int &v = g.edges[i].to;
		dp[v] += dp[x];
		dfs2(v);
	}
}

int main() {
	scanf("%d", &n);
	scanf("%s", s + 1);
	for (int i = 2; i <= n; i++) {
		scanf("%d", &f[i]);
		g.addedge(f[i], i);
	}
	dfs1(1);
	dfs2(1);
	for (int i = 1; i <= n; i++) ans ^= i * dp[i];
	printf("%lld\n", ans);
	return 0;
}
```

#### [CQOI2007]涂色
https://www.luogu.com.cn/problem/P4170

因为涂的是一个区间所以想到区间 DP，设$dp[i][j]$表示$[i,j]$涂成目标状态需要的最少次数，那么有两种决策，一种是若$s[i]=s[j]$，那么可以由$dp[i+1][j-1]$转移来，另一种是通用的，直接枚举中间点，合并两个子区间。

```cpp
#include<cstdio>
#include<cstring>

int n, dp[55][55];
char s[55];

inline int min(int a, int b) { return a < b ? a : b; }

int main() {
	scanf("%s", s + 1);
	n = strlen(s + 1);
	memset(dp, 0x3f, sizeof dp);
	for (int i = 1; i <= n; i++) dp[i][i] = dp[i][i - 1] = 1;
	for (int l = 2; l <= n; l++)
		for (int i = 1; i + l - 1 <= n; i++) {
			int j = i + l - 1;
			if (s[i] == s[j]) dp[i][j] = min(dp[i][j], min(dp[i + 1][j], dp[i][j - 1]));
			for (int k = i; k < j; k++) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
		}
	printf("%d\n", dp[1][n]);
	return 0;
}
```

#### [TJOI2007]调整队形
https://www.luogu.com.cn/problem/P3847

看完题面可以发现是一个区间 DP，但是转移感觉不太明白，但我决定先写一个试试，尽量不依靠题解。然后瞎编了两种转移方式，没想到交上去直接过了，挺好的。

代码中第一种转移对应加入/删除一个人，第二种转移对应改变一个人的颜色。

```cpp
#include<cstdio>
#include<cstring>

int n, w[3010], dp[3010][3010];

inline int min(int a, int b) { return a < b ? a : b; }

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
	memset(dp, 0x3f, sizeof dp);
	for (int i = 1; i <= n; i++) dp[i][i] = dp[i][i - 1] = 0;
	for (int l = 2; l <= n; l++)
		for (int i = 1; i + l - 1 <= n; i++) {
			int j = i + l - 1;
			dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
			if (w[i] == w[j]) dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);
			else dp[i][j] = min(dp[i][j], dp[i + 1][j - 1] + 1);
		}
	printf("%d\n", dp[1][n]);
	return 0;
}
```

#### [BOI2003]Gem 气垫车
https://www.luogu.com.cn/problem/P4395

设$dp[x][i]$表示节点 x 选了权值 i 时子树的最小权值和，那么有

$$dp[x][i]=i+\sum_v\min_{i\not =j}\{dp[v][j]\}$$

因为只有$i\not=j$这一个限制，所以集合$\{dp[v][j]\}$中要么取最小值，要么取次小值，那么就可以只存最小值，次小值和取最小值时 j 的值。DP 时若子节点取最小值时的 j 和当前枚举到的权值相同，则需要取次小值。然后就把这个$O(n^2)$做法优化到了$O(n)$。

代码实现中，$sum[j]$存的是当前节点的权值取$j$时实际 DP 值(有些子节点取了次小值)和全部子节点取最小值时的差。之所以不直接存实际 DP 值，是因为这样做其他取最小值的点就不太好算了。总之代码实现也是挺有技巧的。

```cpp
#include<cstdio>
#include<cstring>

int n, f[10100], g[10100], df[10100], sum[10100];
bool vis[10100];
struct edge { int to, next; };
struct graph {
	int ecnt = 1, head[10100];
	edge edges[20100];
	inline void addedge(int u, int v) {
		edges[++ecnt].to = v;
		edges[ecnt].next = head[u];
		head[u] = ecnt;
	}
}gr;

inline void upd(int x, int v, int dv) {
	if (v < f[x]) { g[x] = f[x]; f[x] = v; df[x] = dv; }
	else if (v < g[x]) g[x] = v;
}
void dfs(int x, int lst) {
	int s = 0, cur = 1;
	for (int i = gr.head[x]; i; i = gr.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		dfs(gr.edges[i].to, i);
	}
	for (int i = gr.head[x]; i; i = gr.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		int &v = gr.edges[i].to;
		s += f[v];
		sum[df[v]] += g[v] - f[v]; vis[df[v]] = true;
	}
	while (vis[cur]) cur++; upd(x, s + cur, cur);
	cur++; while (vis[cur]) cur++; upd(x, s + cur, cur);
	for (int i = gr.head[x]; i; i = gr.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		int &v = gr.edges[i].to;
		if (!vis[df[v]]) continue;
		upd(x, s + sum[df[v]] + df[v], df[v]);
		sum[df[v]] = 0; vis[df[v]] = false;
	}
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i < n; i++) {
		int u, v; scanf("%d%d", &u, &v);
		gr.addedge(u, v); gr.addedge(v, u);
	}
	memset(f, 0x3f, sizeof f);
	memset(g, 0x3f, sizeof g);
	dfs(1, 0);
	printf("%d\n", f[1]);
	return 0;
}
```

#### [CEOI2010 day2] pin
https://www.luogu.com.cn/problem/P6521

恰好 d 个位置不同，相当于恰好 4 - d 个位置相同。可以容斥一下，设$f[i]$表示恰好 i 个位置相同的个数，$g[i]$表示枚举哪 i 个位置相同，然后计算得出的个数(也被称为钦定 i 个位置相同的个数)，那么有：

$$f[i]=g[i]-\sum_{j=i+1}^4\binom{j}{i}f[j]$$

实际上就是枚举有多少个满足大于 i 个位置相同，设为 j ，然后每个对在$g[i]$中被计算了$\binom{j}{i}$次，直接减去即可。

另一种做法是二项式反演。同样设$f[i]$表示恰好，$g[i]$表示钦定，那么有：

$$g[i]=\sum_{j=i}^4\binom{j}{i}f[j]$$

直接套反演公式，得

$$f[i]=\sum_{j=i}^4(-1)^{j-i}\binom{j}{i}g[j]$$

同样可以得出正确答案。

二项式反演也叫广义容斥，至于为什么叫广义容斥我也不懂，感觉它只是用了一下容斥原理。有三种形式：

$$f(i)=\sum_{j=0}^i(-1)^j\binom{i}{j}g(j)\Leftrightarrow g(i)=\sum_{j=0}^i(-1)^j\binom{i}{j}f(j)$$

这个好像没啥用。

$$g(i)=\sum_{j=a}^i\binom{i}{j}f(j)\Leftrightarrow f(i)=\sum_{j=a}^i(-1)^{i-j}\binom{i}{j}g(j)$$

令$g(i)$表示钦定选最多 i 个的方案数，$f(i)$表示选恰好 i 个的方案数，那么就可以利用它实现两者之间的转化。

$$g(i)=\sum_{j=i}^n\binom{j}{i}f(j)\Leftrightarrow f(i)=\sum_{j=i}^n(-1)^{j-i}\binom{j}{i}g(j)$$

令$g(i)$表示钦定选最少 i 个的方案数，$f(i)$表示选恰好 i 个的方案数，那么也可以利用它实现两者之间的转化。

```cpp
#include<cstdio>
#include<cstring>
#include<map>
#include<string>
#include<iostream>

int n, d, binom[5][5], ans, f[5], g[5];
std::map<std::string, int> cnt;

inline int bit(int x) {
	int ans = 0;
	for (; x; x = (x - 1) & x) ans++;
	return ans;
}

int main() {
	scanf("%d%d", &n, &d);
	d = 4 - d;
	binom[0][0] = 1;
	for (int i = 1; i <= 4; i++)
		for (int j = 0; j <= 4; j++) binom[i][j] = binom[i - 1][j] + binom[i - 1][j - 1];
	for (int i = 1; i <= n; i++) {
		memset(f, 0, sizeof f); memset(g, 0, sizeof g);
		std::string str;
		std::cin >> str;
		for (int s = 0; s <= 15; s++) {
			std::string str1; str1.resize(4);
			for (int j = 0; j < 4; j++) {
				if (s & (1 << j)) str1[j] = str[j];
				else str1[j] = '$';
			}
			if (cnt.count(str1)) g[bit(s)] += cnt[str1];
			cnt[str1]++;
		}
		for (int i = 4; i >= d; i--) {
			f[i] = g[i];
			for (int j = i + 1; j <= 4; j++) f[i] -= binom[j][i] * f[j];
		}
		ans += f[d];
	}
	printf("%d\n", ans);
	return 0;
}
```

### 2020-10-21
子集反演：

$$g(S)=\sum_{T\subseteq S}f(T)\Leftrightarrow f(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}g(T)$$

$$g(S)=\sum_{T\supseteq S}f(T)\Leftrightarrow f(S)=\sum_{T\supseteq S}(-1)^{|T|-|S|}g(T)$$

证明可以考虑下面两个式子：

$$\sum_{T\subseteq S}(-1)^{|T|}=\sum_{|T|=0}^{|S|}(-1)^{|T|}\binom{|S|}{|T|}=(1-1)^{|S|}=[S=\varnothing]$$

$$\sum_{T\subseteq S}(-1)^{|S|-|T|}=\sum_{|T|=0}^{|S|}(-1)^{|S|-|T|}\binom{|S|}{|T|}=(1-1)^{|S|}=[S=\varnothing]$$

于是得到

$$\sum_{T\subseteq S}(-1)^{|S|-|T|}g(T)\\\\=\sum_{U\subseteq S}f(U)\sum_{U\subseteq T\subseteq S}(-1)^{|S|-|T|}\\\\=\sum_{U\subseteq S}f(U)\sum_{T\subseteq S-U}(-1)^{|S-U|-|T|}\\\\=\sum_{U\subseteq S}f(U)[S=U]\\\\=f(S)$$

$$\sum_{T\supseteq S}(-1)^{|T|-|S|}g(T)\\\\=\sum_{U\supseteq S}f(U)\sum_{U\supseteq T\supseteq S}(-1)^{|T|-|S|}\\\\=\sum_{U\supseteq S}f(U)\sum_{U-S\supseteq T}(-1)^{|T|}\\\\=\sum_{U\supseteq S}f(U)[S=U]\\\\=f(S)$$

当$f(S)$的值只与$|S|$有关时，通过子集反演的两个公式分别可以导出二项式反演的两个形式。

#### 已经没有什么好害怕的了
https://www.luogu.com.cn/problem/P4859

若有$x$对满足$a>b$，那么有$x-(n-x)=k$，解得$x=\dfrac{n+k}{2}$，所以当$n+k\equiv 1\pmod 2$时方案数为 0 ，否则可以转化为有$\dfrac{n+k}{2}$对满足$a>b$。

设$f(i)$表示有恰好 i 对满足条件的方案数，$g(i)$表示钦定 i 对满足条件的计算值，$dp[i][j]$表示 a 数组的前 i 个位置配对了 j 个满足条件的对时配对方案的数量，那么有：

$$dp[i][j]=dp[i-1][j]+(cnt(i)-(j-1))dp[i-1][j-1]$$

$$g(i)=\sum_{j=i}^n\binom{j}{i}f(j)\\=(n-i)!\cdot dp[n][i]$$

由二项式反演得

$$f(i)=\sum_{j=i}^n(-1)^{j-i}\binom{j}{i}g(j)$$

根据公式计算即可。

```cpp
#include<cstdio>
#include<algorithm>

const int MOD = 1e9 + 9;
int n, k, a[2010], b[2010], dp[2010][2010], f[2010], g[2010], fac[2010], binom[2010][2010], ans;

int main() {
	scanf("%d%d", &n, &k);
	fac[0] = 1;
	for (int i = 1; i <= n; i++) fac[i] = (long long)fac[i - 1] * i % MOD;
	binom[0][0] = 1;
	for (int i = 1; i <= n; i++)
		for (int j = 0; j <= i; j++) {
			binom[i][j] = binom[i - 1][j];
			if (j) binom[i][j] = (binom[i][j] + binom[i - 1][j - 1]) % MOD;
		}
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
	std::sort(a + 1, a + n + 1);
	std::sort(b + 1, b + n + 1);
	int cur = 1;
	dp[0][0] = 1;
	for (int i = 1; i <= n; i++) {
		while (cur <= n && b[cur] < a[i]) cur++;
		for (int j = 0; j <= i; j++) {
			dp[i][j] = dp[i - 1][j];
			if (j) dp[i][j] = (dp[i][j] + (long long)(cur - 1 - (j - 1)) * dp[i - 1][j - 1] % MOD) % MOD;
		}
	}
	for (int i = 0; i <= n; i++) g[i] = (long long)dp[n][i] * fac[n - i] % MOD;
	if ((n + k) % 2) printf("0\n");
	else for (int j = (n + k) / 2, op = 1; j <= n; j++, op *= -1) ans = (ans + (long long)op * binom[j][(n + k) / 2] * g[j] % MOD + MOD) % MOD;
	printf("%d\n", ans);
	return 0;
}
```

#### [USACO20FEB]Delegation P
https://www.luogu.com.cn/problem/P6142

和赛道修建那题基本一样的，注意特判当前节点是 1 时的情况即可。

```cpp
#include<cstdio>
#include<set>

int n;
bool ok;
struct edge { int to, next; };
struct graph {
	int ecnt = 1, head[100100];
	edge edges[200100];
	inline void addedge(int u, int v) {
		edges[++ecnt].to = v;
		edges[ecnt].next = head[u];
		head[u] = ecnt;
	}
}g;

inline int max(int a, int b) { return a > b ? a : b; }
int dfs(int x, int lst, int mid) {
	if (!ok) return 0;
	int ans = 0, cnt = 0;
	std::multiset<int> s;
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		int &v = g.edges[i].to;
		s.insert(dfs(v, i, mid) + 1);
	}
	if ((x == 1 && (s.size() & 1)) || (x != 1 && !(s.size() & 1))) s.insert(0);
	while (!s.empty() && ok) {
		std::multiset<int>::iterator i = s.begin(), p = s.lower_bound(mid - *i);
		if (i == p) p++;
		if (x == 1) {
			if (p == s.end()) ok = false;
			else s.erase(p);
		}
		else {
			if (p == s.end() && cnt) ok = false;
			else if (p == s.end() && !cnt) ans = *i, cnt = 1;
			else if (p != s.end()) s.erase(p);
		}
		s.erase(i);
	}
	return ans;
}
inline bool check(int mid) {
	ok = true;
	dfs(1, 0, mid);
	return ok;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i < n; i++) {
		int u, v; scanf("%d%d", &u, &v);
		g.addedge(u, v); g.addedge(v, u);
	}
	int l = 1, r = n;
	while (l < r) {
		int mid = l + (r - l >> 1);
		if (check(mid)) l = mid + 1;
		else r = mid;
	}
	printf("%d\n", l - 1);
	return 0;
}
```

#### [JSOI2011]分特产
https://www.luogu.com.cn/problem/P5505

限制是每个同学都要分到特产，那么可以设$g(i)$表示钦定 i 个同学没有分到，$f(i)$表示恰好 i 个同学没有分到的方案数，那么有：

$$g(i)=\binom{n}{i}\prod_{j=1}^m\binom{a_j+n-i-1}{n-i-1}\\\\=\sum_{j=i}^n\binom{j}{i}f(j)$$

其中$\binom{n}{i}$是枚举哪 i 个同学没有分到，$\binom{a_j+n-i-1}{n-i-1}$的意思是把$a_j$个球分到$n-i$个盒子里，可以有空盒的方案数，根据乘法原理乘起来。

反演一下得到

$$f(i)=\sum_{j=i}^n(-1)^{j-i}\binom{j}{i}g(j)$$

代入 i = 0

$$f(0)=\sum_{j=0}^n(-1)^jg(j)$$

根据公式计算即可。

```cpp
#include<cstdio>

const int MOD = 1e9 + 7;
int n, m, a[1010], binom[2010][2010], g[1010], ans;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) scanf("%d", &a[i]);
	for (int i = 0; i <= 2000; i++) binom[i][0] = 1;
	for (int i = 1; i <= 2000; i++)
		for (int j = 1; j <= i; j++) binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;
	for (int i = 0; i <= n; i++) {
		g[i] = binom[n][i];
		for (int j = 1; j <= m; j++) g[i] = (long long)g[i] * binom[a[j] + n - i - 1][n - i - 1] % MOD;
	}
	for (int j = 0, op = 1; j <= n; j++, op *= -1) ans = (ans + (op * g[j] + MOD) % MOD) % MOD;
	printf("%d\n", ans);
	return 0;
}
```