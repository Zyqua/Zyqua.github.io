王道征途――NOIP2020冲刺计划・第十九周(10.26~11.1)
2020-11-04
20201026
<!--more-->
### 2020-10-26
#### [SDOI2010]地精部落
https://www.luogu.com.cn/problem/P2467

若高度为 j 的位置和高度为 j - 1 的位置不相邻，则交换这两个位置，可以产生一个新的合法排列；将所有$h_i$变为$n+1-h_i$，也可以得到一个新的合法排列。设$dp[i][j]$表示长度为 i ，第 i 位高度为 j 且是山峰的方案数，有：

$$dp[i][j]=dp[i][j-1]+dp[i-1][i-j+1]$$

若 j 与 j - 1 的位置不相邻，则交换两个位置，得到长度为 i ，最后一位是 j - 1，且最后一位是山峰的排列，对应$dp[i][j-1]$；若相邻，则第 i - 1 位是 j - 1，且第 i - 1 位是山谷，把排列的所有$h_i$变为$n+1-h_i$，得到第 i - 1 位是 i - j + 1，且第 i - 1 位山峰的排列，对应$dp[i-1][i-j+1]$。

这个做法比较神仙，不容易想出来。另一种更容易想到的做法是设$dp[i]$表示 1 到 i 的数组成的第一个位置是山峰的合法排列数，然后有：

$$dp[i]=\sum_{j=1}^i[j\bmod 2=1]\binom{i-1}{j-1}dp[j-1]\cdot dp[i-j]$$

其中 j 表示枚举 i 在第 j 个位置，因为 i 一定是山峰所以 j 一定是奇数。$\dbinom{i-1}{j-1}dp[j-1]$表示枚举在剩下 i - 1 个数中的$j-1$个放在 i 左边并组成合法排列的方案数，$dp[i-j]$表示把剩下的数放在右边并组成合法排列的方案数。注意第 j + 1 个位置一定是山谷，但$dp[i-j]$中第一位是山峰，这样做正确的原因是第一位是山峰和第一位是山谷的方案数相等。

还有好多做法，不一一写了，参考资料：https://www.cnblogs.com/cj-chd/p/9967904.html 。

```cpp
#include<cstdio>

int n, p, dp[4210][4210], ans;

int main() {
	scanf("%d%d", &n, &p);
	dp[1][1] = 1;
	for (int i = 2; i <= n; i++)
		for (int j = 1; j <= i; j++) dp[i][j] = (dp[i][j - 1] + dp[i - 1][i - j + 1]) % p;
	for (int i = 1; i <= n; i++) ans = (ans + dp[n][i] * 2 % p) % p;
	printf("%d\n", ans);
	return 0;
}
```

#### 白雪皑皑
https://www.luogu.com.cn/problem/P2391

常见套路，可以把操作倒过来做，用并查集维护，每次把染过色的都合并，操作时直接跳过染过色的，这样每个位置只会被染色一次，复杂度$O(n\log n)$。

```cpp
#include<cstdio>

int n, m, p, q, c[1000100];
inline void swap(int &a, int &b) { int t = a; a = b; b = t; }
struct usetnode { int fa; };
struct uset {
	usetnode nds[1000100];
	int find(int x) {
		if (nds[x].fa == x) return x;
		return nds[x].fa = find(nds[x].fa);
	}
	inline void merge(int x, int y) {
		x = find(x), y = find(y);
		if (x < y) swap(x, y);
		nds[y].fa = x;
	}
	inline void init() { for (int i = 1; i <= n + 1; i++) nds[i].fa = i; }
}uset;

int main() {
	scanf("%d%d%d%d", &n, &m, &p, &q);
	uset.init();
	for (int i = m; i >= 1; i--) {
		int l = (i * p + q) % n + 1, r = (i * q + p) % n + 1;
		if (l > r) swap(l, r);
		for (int j = uset.find(l); j <= r; j = uset.find(j)) c[j] = i, uset.merge(j, j + 1);
	}
	for (int i = 1; i <= n; i++) printf("%d\n", c[i]);
	return 0;
}
```

#### Gerald and Giant Chess
https://www.luogu.com.cn/problem/CF559C

棋盘比较大，而黑格子比较少，可以围绕黑格子进行 DP。将终点也看作黑格子，设$dp[i]$表示从起点到达第 i 个黑格子且不经过其他黑格子的方案数，那么根据减法公式有：

$$dp[i]=\binom{x_i+y_i-2}{x_i-1}-\sum_{valid(j)}dp[j]\cdot\binom{x_i-x_j+y_i-y_j}{x_i-x_j}$$

其中$valid(j)$表示第 j 个黑格子可以到达第 i 个黑格子。

```cpp
#include<cstdio>
#include<algorithm>

const int MOD = 1e9 + 7;
int h, w, n, dp[2010], fac[200100], invfac[200100];
struct coordinate {
	int x, y;
	bool operator < (const coordinate &b) const {
		if (x != b.x) return x < b.x;
		return y < b.y;
	}
}cdts[2010];

void exgcd(int a, int b, int &x, int &y) {
	if (!b) { x = 1; y = 0; return; }
	exgcd(b, a % b, y, x);
	y -= a / b * x;
}
inline int inv(int a) { int x, y; exgcd(a, MOD, x, y); return (x % MOD + MOD) % MOD; }
inline int binom(int n, int m) { return (long long)fac[n] * invfac[m] % MOD * invfac[n - m] % MOD; }

int main() {
	scanf("%d%d%d", &h, &w, &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &cdts[i].x, &cdts[i].y);
	cdts[0].x = 1, cdts[0].y = 1; cdts[n + 1].x = h, cdts[n + 1].y = w;
	n++;
	std::sort(cdts + 1, cdts + n + 1);
	fac[0] = 1;
	for (int i = 1; i <= h + w; i++) fac[i] = (long long)fac[i - 1] * i % MOD;
	invfac[h + w] = inv(fac[h + w]);
	for (int i = h + w - 1; i >= 0; i--) invfac[i] = (long long)invfac[i + 1] * (i + 1) % MOD;
	for (int i = 1; i <= n; i++) {
		dp[i] = binom(cdts[i].x + cdts[i].y - 2, cdts[i].x - 1);
		for (int j = 1; j < i; j++)
			if (cdts[j].y <= cdts[i].y) dp[i] = (dp[i] - (long long)binom(cdts[i].x + cdts[i].y - cdts[j].x - cdts[j].y, cdts[i].x - cdts[j].x) * dp[j] % MOD + MOD) % MOD;
	}
	printf("%d\n", dp[n]);
	return 0;
}
```

#### 天天爱跑步
https://www.luogu.com.cn/problem/P1600

常用技巧，桶+差分统计子树信息。将一条路径分为起点到顶端，以及顶端的子节点到终点两部分，然后对每个节点统计有多少玩家能被观察到，稍微推推式子，不难发现只要起点或终点在子树内，且满足以下条件之一：

$$w[x]+depth[x]=depth[s]$$

$$w[x]-depth[x]=dis-depth[t]$$

其中$s,t$分别表示起点和终点，$dis$表示 s 到 t 的路径长度。另外设$ca$表示$s,t$的$lca$。

可以设想在起点到顶端这条路径上加入$depth[s]$这个值，在顶端的子节点到终点这条路径上加入$dis-depth[t]$这个值，那么我们分别枚举所有节点，然后看看在这个节点上有几个$depth[s]$与$w[x]+depth[x]$相等，有几个$dis-depth[t]$与$w[x]-depth[x]$相等即可。像这种多次操作，最后统一询问的问题，显然可以直接树上差分解决。至于存储插入的值，可以用`std::vector`。

现在的问题是如何统计在当前节点上某种值有几个，不难想到用桶。然而每个节点都开一个桶显然不行，这就用到了桶+差分的技巧，即开一个桶记录当前所有已经访问过的节点所有的值的个数，然后子树内的个数等于遍历子树后的个数减去遍历前的个数。这个技巧之前也写过，就不多说了。这样整个问题就解决了，总复杂度$O(n)$。

如果实在不会桶+差分也可以直接线段树合并，也是很好理解的，不过复杂度是$O(n\log n)$的，而且常数很大，占的空间也多。好像还能树上启发式合并，不过我不会。

```cpp
#include<cstdio>
#include<vector>
#include<utility>

int n, m, ans[300100], w[300100], f[300100][20], depth[300100], cnt1[600100], cnt2[600100];
struct edge { int to, next; };
struct graph {
	int ecnt = 1, head[300100];
	edge edges[600100];
	inline void addedge(int u, int v) {
		edges[++ecnt].to = v;
		edges[ecnt].next = head[u];
		head[u] = ecnt;
	}
}g;
std::vector<std::pair<int, int> > w1[300100], w2[300100];

void dfs1(int x, int lst) {
	depth[x] = depth[g.edges[lst ^ 1].to] + 1;
	f[x][0] = g.edges[lst ^ 1].to;
	for (int i = 1; i < 20; i++) f[x][i] = f[f[x][i - 1]][i - 1];
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		dfs1(g.edges[i].to, i);
	}
}
inline void swap(int &a, int &b) { int t = a; a = b; b = t; }
inline int lca(int x, int y) {
	if (depth[x] < depth[y]) swap(x, y);
	for (int i = 19; i >= 0; i--)
		if (depth[f[x][i]] >= depth[y]) x = f[x][i];
	if (x == y) return x;
	for (int i = 19; i >= 0; i--)
		if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}
void dfs2(int x, int lst) {
	int s1 = cnt1[w[x] + depth[x]], s2 = cnt2[w[x] - depth[x] + n];
	for (std::vector<std::pair<int, int> >::iterator i = w1[x].begin(); i != w1[x].end(); i++) cnt1[i -> first] += i -> second;
	for (std::vector<std::pair<int, int> >::iterator i = w2[x].begin(); i != w2[x].end(); i++) cnt2[i -> first] += i -> second;
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		dfs2(g.edges[i].to, i);
	}
	ans[x] += cnt1[w[x] + depth[x]] - s1 + cnt2[w[x] - depth[x] + n] - s2;
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i++) {
		int u, v; scanf("%d%d", &u, &v);
		g.addedge(u, v); g.addedge(v, u);
	}
	dfs1(1, 0);
	for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
	for (int i = 1; i <= m; i++) {
		int s, t; scanf("%d%d", &s, &t);
		int ca = lca(s, t), dis = depth[s] + depth[t] - (depth[ca] << 1);
		w1[s].push_back(std::make_pair(depth[s], 1));
		w1[f[ca][0]].push_back(std::make_pair(depth[s], -1));
		w2[t].push_back(std::make_pair(dis - depth[t] + n, 1));
		w2[ca].push_back(std::make_pair(dis - depth[t] + n, -1));
	}
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) printf("%d ", ans[i]);
	return 0;
}
```

#### [SCOI2007]排列
https://www.luogu.com.cn/problem/P4163

十分套路的状压，设$dp[s][i]$表示由状态 s 里的所有数组成的排列中模 d 等于 i 个方案数，那么直接枚举在末尾接上哪个数，使用刷表法更新即可。虽然我不喜欢刷表法，但是这题填表法似乎不太好做。

然而给出的数字里有重复，需要去重，直接计一下每种数的个数，然后除以对应的阶乘即可。

虽然总感觉只是接在末尾不太对，但这样确实是对的，而且不管第二维的话复杂度是$O(2^nn)$，相比$O(n!)$要优得多，有点神奇。

```cpp
#include<cstdio>
#include<cstring>

int t, n, d, dp[1100][1010], cnt[10], fac[11], ans;
char s[11];

int main() {
	fac[0] = 1;
	for (int i = 1; i <= 10; i++) fac[i] = fac[i - 1] * i;
	scanf("%d", &t);
	while (t--) {
		memset(dp, 0, sizeof dp); memset(cnt, 0, sizeof cnt);
		scanf("%s %d", s + 1, &d);
		n = strlen(s + 1);
		for (int i = 1; i <= n; i++) cnt[s[i] - '0']++;
		dp[0][0] = 1;
		for (int stt = 0; stt < (1 << n); stt++)
			for (int i = 0; i < d; i++)
				for (int j = 1; j <= n; j++)
					if (!(stt & (1 << j - 1))) dp[stt | (1 << j - 1)][(i * 10 + s[j] - '0') % d] += dp[stt][i];
		ans = dp[(1 << n) - 1][0];
		for (int i = 0; i <= 9; i++) ans /= fac[cnt[i]];
		printf("%d\n", ans);
	}
	return 0;
}
```

### 2020-10-27
#### [HNOI2012]集合选数
https://www.luogu.com.cn/problem/P3226

一个有趣的构造思路：将一个数的三倍放在右边，二倍放在下边，那么相当于在二维矩阵中选择若干不相邻的数(正睿的题中也有类似思路，不过是一维情况)，可以直接状压求方案数。

枚举所有数，如果当前数没有被加入到矩阵过那么就以它为左上角构造矩阵。由唯一分解定理可以知道每个数只会被放在一个矩阵中。显然矩阵的长和宽都是$\log$级别的，因此状压的复杂度可以接受。

把`dp[19][2050]`写成了`dp[2050][19]`调了一个多小时。

```cpp
#include<cstdio>
#include<cstring>

const int MOD = 1e9 + 1;
int n, dp[19][2050], a[19][11], len[19], rcnt, ans = 1;
bool vis[100100];

int main() {
	scanf("%d", &n);
	for (int x = 1; x <= n; x++) {
		if (vis[x]) continue;
		a[1][1] = x; vis[x] = true; rcnt = len[1] = 1;
		for (int j = 2; a[1][j - 1] * 3 <= n; j++) a[1][j] = a[1][j - 1] * 3, len[1] = j, vis[a[1][j]] = true;
		for (int i = 2; a[i - 1][1] * 2 <= n; i++) {
			a[i][1] = a[i - 1][1] * 2; vis[a[i][1]] = true; len[i] = 1;
			for (int j = 2; a[i][j - 1] * 3 <= n; j++) a[i][j] = a[i][j - 1] * 3, len[i] = j, vis[a[i][j]] = true;
			rcnt = i;
		}
		memset(dp, 0, sizeof dp);
		dp[0][0] = 1;
		for (int i = 1; i <= rcnt; i++) {
			for (int s = 0; s < (1 << len[i]); s++) {
				if (s & (s << 1)) continue;
				for (int s1 = 0; s1 < (1 << len[i - 1]); s1++) {
					if ((s1 & (s1 << 1)) || (s & s1)) continue;
					dp[i][s] = (dp[i][s] + dp[i - 1][s1]) % MOD;
				}
			}
		}
		int ansx = 0;
		for (int s = 0; s < (1 << len[rcnt]); s++) ansx = (ansx + dp[rcnt][s]) % MOD;
		ans = (long long)ans * ansx % MOD;
	}
	printf("%d\n", ans);
	return 0;
}
```

#### [JSOI2018]潜入行动
https://www.luogu.com.cn/problem/P4516

设$dp[x][j][0/1][0/1]$表示以节点 x 为根的子树内放了 j 个监控，且子树内除 x 外的节点都被覆盖，且 x 自身 没有 / 有 放监控，没有 / 有 被覆盖时的方案数。然后树形背包+分类讨论即可。

因为在转移时 k 可以等于 0，所以像以前写的那样滚动数组的话会导致错误的状态转移，再开个数组存一下上一个子节点更新完后的 dp 值即可。

```cpp
#include<cstdio>

const int MOD = 1e9 + 7;
int n, m, dp[100100][110][2][2], dpb[100100][110][2][2], size[100100];
struct edge { int to, next; };
struct graph {
	int ecnt = 1, head[100100];
	edge edges[200100];
	inline void addedge(int u, int v) {
		edges[++ecnt].to = v;
		edges[ecnt].next = head[u];
		head[u] = ecnt;
	}
}g;

inline int min(int a, int b) { return a < b ? a : b; }
inline int max(int a, int b) { return a > b ? a : b; }
void dfs(int x, int lst) {
	size[x] = dp[x][0][0][0] = dp[x][1][1][0] = 1;
	for (int i = g.head[x]; i; i = g.edges[i].next) {
		if ((i ^ lst) == 1) continue;
		int &v = g.edges[i].to;
		dfs(v, i);
		for (int j = min(size[x] + size[v], m); j >= 0; j--) {
			dpb[x][j][0][0] = dp[x][j][0][0], dp[x][j][0][0] = 0;
			dpb[x][j][0][1] = dp[x][j][0][1], dp[x][j][0][1] = 0;
			dpb[x][j][1][0] = dp[x][j][1][0], dp[x][j][1][0] = 0;
			dpb[x][j][1][1] = dp[x][j][1][1], dp[x][j][1][1] = 0;
		}
		for (int j = min(size[x] + size[v], m); j >= 0; j--) {
			for (int k = max(j - size[x], 0); k <= j && k <= size[v]; k++) {
				dp[x][j][0][0] = (dp[x][j][0][0] + (long long)dpb[x][j - k][0][0] * dp[v][k][0][1] % MOD) % MOD;
				dp[x][j][0][1] = (dp[x][j][0][1] + (long long)dpb[x][j - k][0][1] * (dp[v][k][0][1] + dp[v][k][1][1]) % MOD + (long long)dpb[x][j - k][0][0] * dp[v][k][1][1] % MOD) % MOD;
				dp[x][j][1][0] = (dp[x][j][1][0] + (long long)dpb[x][j - k][1][0] * (dp[v][k][0][0] + dp[v][k][0][1]) % MOD) % MOD;
				dp[x][j][1][1] = (dp[x][j][1][1] + (long long)dpb[x][j - k][1][1] * (((long long)dp[v][k][0][0] + dp[v][k][0][1] + dp[v][k][1][0] + dp[v][k][1][1]) % MOD) % MOD + (long long)dpb[x][j - k][1][0] * (dp[v][k][1][0] + dp[v][k][1][1]) % MOD) % MOD;
			}
		}
		size[x] += size[v];
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i++) {
		int u, v; scanf("%d%d", &u, &v);
		g.addedge(u, v); g.addedge(v, u);
	}
	dfs(1, 0);
	printf("%d\n", (dp[1][m][0][1] + dp[1][m][1][1]) % MOD);
	return 0;
}
```

### 2020-10-28
#### [JLOI2013]卡牌游戏
#### [USACO13OPEN]Photo G
https://www.luogu.com.cn/problem/P3084

设$dp[i]$表示第 i 个位置一定有一个点时，前 i 个位置最多有几个点。

一个技巧是把每个区间的点数一定是 1 这个条件拆为每个区间的点数小于等于 1 且大于等于 1。由区间点数小于等于 1 ，可以得出对于所有包含 i 的区间$[l,r]$，$dp[i]$能转移来的范围都小于 l 。由区间点数大于等于 1，可以得出对于所有右端点在 i 左侧的区间$[l,r]$，$dp[i]$能转移来的范围都大于等于 l 。由此可以确定$dp[i]$能转移来的范围。

具体来说可以在每个位置存一下所有右端点恰好在这个位置的所有区间。设所有包含 i 的区间的最小 l 为$minl[i]$，所有在 i 左侧的最大 l 为$maxl[i]$，那么$minl[i]$可以先继承$minl[i+1]$的值，然后再在以 i 为右端点的区间的 l 中取最小值，复杂度$O(n+m)$。这样写正确的原因是$minl[i+1]$对应的区间可能包含 i ，这时拿来更新$minl[i]$显然是对的；否则不包含 i ，这时并不影响 i 的答案更新，因为这时以 i 为右端点的区间的左端点一定小于$minl[i+1]$。不过当不存在以 i 为右端点的区间时，这时得出的$minl[i]$显然是错的，所以在继承$minl[i+1]$时还要和 i 取最小值。

$maxl[i]$的求解也是同理，不过不用考虑边界情况。

不难发现$[maxl[i],minl[i])$是单调递增的，于是可以用单调队列优化一下，总复杂度$O(n+m)$。

不过有的位置是不可能有点的，所以当第 i 个位置不可能有点时，令$dp[i]=-1$，然后 DP 时判断一下就可以了。至于最后的答案可以再增加一个第 n + 1 个位置，然后答案显然就是$dp[n+1]-1$。

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<utility>

int n, m, dp[200100], minl[200100], maxl[200100], ans = -1;
std::vector<int> sec[200100];
std::deque<std::pair<int, int> > q;

inline int min(int a, int b) { return a < b ? a : b; }
inline int max(int a, int b) { return a > b ? a : b; }

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) {
		int l, r; scanf("%d%d", &l, &r);
		sec[r].push_back(l);
	}
	minl[n + 1] = n + 1;
	for (int i = n; i >= 1; i--) {
		minl[i] = min(minl[i + 1], i);
		for (std::vector<int>::iterator j = sec[i].begin(); j != sec[i].end(); j++) minl[i] = min(minl[i], *j);
	}
	for (int i = 1; i <= n + 1; i++) {
		maxl[i] = maxl[i - 1];
		for (std::vector<int>::iterator j = sec[i - 1].begin(); j != sec[i - 1].end(); j++) maxl[i] = max(maxl[i], *j);
	}
	int cur = 0;
	for (int i = 1; i <= n + 1; i++) {
		while (cur < minl[i]) {
			if (dp[cur] == -1) { cur++; continue; }
			while (!q.empty() && q.back().second <= dp[cur]) q.pop_back();
			q.push_back(std::make_pair(cur, dp[cur]));
			cur++;
		}
		while (!q.empty() && q.front().first < maxl[i]) q.pop_front();
		if (!q.empty()) dp[i] = q.front().second + 1;
		else dp[i] = -1;
	}
	if (dp[n + 1] != -1) printf("%d\n", dp[n + 1] - 1);
	else printf("-1\n");
	return 0;
}
```

$$x^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}\binom{x}{i}i!$$

$$x^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}x^{\underline i}$$

$$\sum_{i=1}^n\binom{n}{i}i^k\\=\sum_{i=1}^n\binom{n}{i}\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\binom{i}{j}j!\\=\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=1}^n\binom{n}{i}\binom{i}{j}\\=\sum_{j=1}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=1}^n\binom{n}{j}\binom{n-j}{i-j}\\=\sum_{j=1}^k\begin{Bmatrix}k\\j\end{Bmatrix}\binom{n}{j}j!\sum_{i=0}^{n-j}\binom{n-j}{i}\\=\sum_{j=1}^k\begin{Bmatrix}k\\j\end{Bmatrix}\binom{n}{j}j!\cdot 2^{n-j}$$